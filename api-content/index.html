{"posts":[{"title":"Framework Archive ","content":"记录下Run Script：合并真机armv7 arm64 模拟器i386 x86_64 为新的framework；同时创建xcframework # 编译产物 # ~Library/Developer/Xcode/DerivedData/LinkPlayLogRecordDemo-cnaglpbkttarzjgcbeksqtomgylq/Build/Products/Debug-universal UNIVERSAL_OUTPUTFOLDER=${BUILD_DIR}/${CONFIGURATION}-universal # Products 路径 INSTALL_DIR=${SRCROOT}/Products # framework 名字 PROJECT_IOT=&quot;LinkPlayLogRecord&quot; # 创建 Debug-universal mkdir -p &quot;${UNIVERSAL_OUTPUTFOLDER}&quot; # 如果有 Products 文件夹，则删除重建 if [ -d &quot;${INSTALL_DIR}&quot; ]; then rm -rf &quot;${INSTALL_DIR}&quot; fi mkdir -p &quot;${INSTALL_DIR}&quot; echo &quot;[FW Script] ---------------- start -----------------&quot; echo &quot;[FW Script] TARGET_BUILD_DIR: ${TARGET_BUILD_DIR}&quot; echo &quot;[FW Script] CONFIGURATION: ${CONFIGURATION}&quot; echo &quot;[FW Script] ACTION: ${ACTION}&quot; # 防止递归 if [ &quot;false&quot; == ${ALREADYINVOKED:-false} ]; then # action 为 install, 并且 TARGET_BUILD_DIR 中包含 LinkPlayLogRecordDemo IPHONEOS_FRAMEWORK_DIR=&quot;${BUILD_DIR}/${CONFIGURATION}-iphoneos/${PROJECT_IOT}.framework&quot; IPHONESIMULATOR_FRAMEWORK_DIR=&quot;${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${PROJECT_IOT}.framework&quot; if [ &quot;${ACTION}&quot; = &quot;install&quot; ] &amp;&amp; [[ &quot;${TARGET_BUILD_DIR}&quot; == *&quot;LinkPlayLogRecordDemo&quot;* ]]; then export ALREADYINVOKED=&quot;true&quot; # 编译模拟器 i386 x86_64 架构的 framework 包 echo &quot;[FW Script] xcodebuild: i386 x86_64&quot; xcodebuild -target &quot;${PROJECT_IOT}&quot; -configuration ${CONFIGURATION} -sdk iphonesimulator -arch i386 -arch x86_64 ONLY_ACTIVE_ARCH=NO BUILD_DIR=&quot;${BUILD_DIR}&quot; BUILD_ROOT=&quot;${BUILD_ROOT}&quot; clean build # copy BUILD_DIR 下 真机包到 universal 文件夹下 echo &quot;[FW Script] copy iphoneos to universal&quot; cp -R &quot;${IPHONEOS_FRAMEWORK_DIR}/&quot; &quot;${UNIVERSAL_OUTPUTFOLDER}/${PROJECT_IOT}.framework&quot; # 合并 模拟器 和 真机 framework，并输出到 universal 文件夹下 IPHONEOS_FILE_DIR=&quot;${IPHONEOS_FRAMEWORK_DIR}/${PROJECT_IOT}&quot; IPHONESIMULATOR_FLIE_DIR=&quot;${IPHONESIMULATOR_FRAMEWORK_DIR}/${PROJECT_IOT}&quot; echo &quot;[FW Script] 合并framework&quot; lipo -create -output &quot;${UNIVERSAL_OUTPUTFOLDER}/${PROJECT_IOT}.framework/${PROJECT_IOT}&quot; ${IPHONESIMULATOR_FLIE_DIR} ${IPHONEOS_FILE_DIR} # 净化代码用的，本地没安装过，暂时注释了 # coan spin &quot;${BUILD_DIR}/${CONFIGURATION}-iphoneos/${PROJECT_IOT}.framework/Headers&quot; --recurse --discard drop --keepgoing --implicit --gag error --define LINKPLAY_PUBLIC_HEADER=1 --define LINKPLAY_CAR_PUBLIC_HEADER=1 # 顺便生成下 xcframework echo &quot;[FW Script] 创建xcframework&quot; xcodebuild -create-xcframework -framework ${IPHONEOS_FRAMEWORK_DIR} -framework ${IPHONESIMULATOR_FRAMEWORK_DIR} -output &quot;${UNIVERSAL_OUTPUTFOLDER}/${PROJECT_IOT}.xcframework&quot; # 打开 Products 文件夹 open &quot;${UNIVERSAL_OUTPUTFOLDER}&quot; # 将其 真机framework copy 到 Products 文件夹下面 cp -R &quot;${IPHONEOS_FRAMEWORK_DIR}/&quot; &quot;${INSTALL_DIR}/${PROJECT_IOT}.framework&quot; else echo &quot;[FW Script] PLATFORM_NAME: ${PLATFORM_NAME}&quot; # 根据 platform 是iphoneos 还是 iphonesimulator 找到对应的 framework 文件 SOURCE_DIR=${IPHONEOS_FRAMEWORK_DIR} if [ ${PLATFORM_NAME} = &quot;iphonesimulator&quot; ]; then SOURCE_DIR=${IPHONESIMULATOR_FRAMEWORK_DIR} fi # 将其 copy 到 Products 文件夹下面 cp -R ${SOURCE_DIR} &quot;${INSTALL_DIR}/${PROJECT_IOT}.framework&quot; fi else echo &quot;[FW Script] 递归 - 跳过&quot; fi echo &quot;[FW Script] ---------------- end -----------------&quot; ","link":"https://daning.netlify.app/post/framework-archive/"},{"title":"将OC转为 C/C++","content":" 例 以 main.m 文件为例 xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp xcrun :Xcode 工具，-sdk: 平台 iphoneos就是iOS平台， -arch: 基于什么架构 苹果手机是基于arm64的，-rewrite-objc :重写oc文件，-o：输出到那个文件，文件名自定义 执行失败 如果被转换的代码中的对象有用到__weak修饰，可能会执行失败 cannot create __weak reference in file using manual reference 解决方式: 支持ARC、更改runtime版本 xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m ","link":"https://daning.netlify.app/post/jiang-oc-zhuan-wei-cc/"},{"title":"WKWebview模拟PC浏览器形式加载url","content":"iPad、Catalyst、MacOS 中的WkWebview 在加载部分url时，会遇到部分按钮点击无效（a标签target = _blank），或者加载不出来的问题（无限重定向） 加载白屏 在使用模拟器 iPad、Catalyst、MacOS端的WKWebview时，例如请求url https://www.baidu.com ，那么会发现无法加载页面，调试发现其后台在不停的重定向，无法正常加载url &lt;head&gt; &lt;script&gt; location.replace(location.href.replace(&quot;https://&quot;,&quot;http://&quot;)); &lt;/script&gt; &lt;/head&gt; 此时我们可以用修改userAgent的方式来避免这个问题： NSString *userAgent； // iPhone userAgent = @&quot;Mozilla/5.0 (iPhone; CPU iPhone OS 8_0_2 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) Version/8.0 Mobile/12A366 Safari/600.1.4&quot;; // Chrome userAgent = @&quot; Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.80 Safari/537.36&quot;; // Safari userAgent = Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.1 Safari/605.1.15 直接赋值 _wkWebView.customUserAgent = userAgent; 或者 WKUserContentController *userContentController = [[WKUserContentController alloc] init]; WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init]; configuration.userContentController = userContentController; configuration.applicationNameForUserAgent = userAgent; self.webView = [[WKWebView alloc] initWithFrame:[UIScreen mainScreen].bounds configuration:configuration]; _blank 点击无效 参考：WKWebView遇到_blank的处理方法 解决方式 核心点在于点击按钮后的 回调 decidePolicyForNavigationAction，有2种修改方式 删除所有a标签的 target属性 - (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler{ // WKNavigationAction 中有两个属性：sourceFrame和targetFrame，分别代表这个action的出处和目标。 // WKFrameInfo有一个 mainFrame 的属性，正是这个属性标记着这个frame是在主frame里还是新开一个frame。 if (!navigationAction.targetFrame.isMainFrame) { [webView evaluateJavaScript:@&quot;var a = document.getElementsByTagName('a');for(var i=0;i&lt;a.length;i++){a[i].setAttribute('target','');}&quot; completionHandler:nil]; } decisionHandler(WKNavigationActionPolicyAllow); } 根据点击的url 重新加载webview - (WKWebView *)webView:(WKWebView *)webView createWebViewWithConfiguration:(WKWebViewConfiguration *)configuration forNavigationAction:(WKNavigationAction *)navigationAction windowFeatures:(WKWindowFeatures *)windowFeatures { WKFrameInfo *frameInfo = navigationAction.targetFrame; if (![frameInfo isMainFrame]) { [webView loadRequest:navigationAction.request]; } return nil; } 注意点 需要处理自动弹出的视频、返回键等问题 ","link":"https://daning.netlify.app/post/wkwebview-mo-ni-pc-liu-lan-qi-xing-shi-jia-zai-url/"},{"title":"性能优化","content":" 性能优化 CPU &amp; GPU CPU（Central Processing Unit，中央处理器） 对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制（Core Graphics） GPU（Graphics Processing Unit，图形处理器） 纹理渲染 iOS是双缓冲机制，分为前帧缓存 和 后帧缓存 卡顿产生的原因 按照60fps的刷帧率，每隔16ms就会有一次VSync信号（上图中每两个VSync之间的时间长度 = 16ms） 解决卡顿的主要思路就是：尽可能的减少CPU、GPU的资源消耗 卡顿优化 - CPU 尽量用轻量级的对象，比如用不到事件处理的地方，可以考虑使用CALayer取代UIView 不要频繁地调用UIView的相关属性，比如frame、bounds、transform等属性，尽量减少不必要的修改 尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性 Autolayout会比直接设置frame消耗更多的CPU资源 图片的size最好刚好跟UIImageView的size保持一致 控制一下线程的最大并发数量 尽量把耗时的操作放到子线程 文本处理（尺寸计算、绘制） 图片处理（解码、绘制） 图片异步解码 - 代码 - (void)image { UIImageView *imageView = [[UIImageView alloc] init]; imageView.frame = CGRectMake(100, 100, 100, 56); [self.view addSubview:imageView]; self.imageView = imageView; dispatch_async(dispatch_get_global_queue(0, 0), ^{ // 获取CGImage CGImageRef cgImage = [UIImage imageNamed:@&quot;timg&quot;].CGImage; // alphaInfo CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(cgImage) &amp; kCGBitmapAlphaInfoMask; BOOL hasAlpha = NO; if (alphaInfo == kCGImageAlphaPremultipliedLast || alphaInfo == kCGImageAlphaPremultipliedFirst || alphaInfo == kCGImageAlphaLast || alphaInfo == kCGImageAlphaFirst) { hasAlpha = YES; } // bitmapInfo CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host; bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst; // size size_t width = CGImageGetWidth(cgImage); size_t height = CGImageGetHeight(cgImage); // context CGContextRef context = CGBitmapContextCreate( NULL, width, height, 8, 0, CGColorSpaceCreateDeviceRGB(), bitmapInfo); // draw CGContextDrawImage(context, CGRectMake(0, 0, width, height), cgImage); // get CGImage cgImage = CGBitmapContextCreateImage(context); // into UIImage UIImage *newImage = [UIImage imageWithCGImage:cgImage]; // release CGContextRelease(context); CGImageRelease(cgImage); // back to the main thread dispatch_async(dispatch_get_main_queue(), ^{ self.imageView.image = newImage; }); }); } 卡顿优化 - GPU 尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示 GPU能处理的最大纹理尺寸是4096x4096，一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸 尽量减少视图数量和层次 减少透明的视图（alpha&lt;1），不透明的就设置opaque为YES 尽量避免出现离屏渲染 离屏渲染 在OpenGL中，GPU有2种渲染方式 On-Screen Rendering：当前屏幕渲染，在当前用于显示的屏幕缓冲区进行渲染操作 Off-Screen Rendering：离屏渲染，在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作 离屏渲染消耗性能的原因 需要创建新的缓冲区 离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕 哪些操作会触发离屏渲染？ 光栅化，layer.shouldRasterize = YES 遮罩，layer.mask 圆角，同时设置layer.masksToBounds = YES、layer.cornerRadius大于0 考虑通过CoreGraphics绘制裁剪圆角 或者叫美工提供圆角图片 阴影，layer.shadowXXX 如果设置了layer.shadowPath就不会产生离屏渲染 卡顿检测 平时所说的“卡顿”主要是因为在主线程执行了比较耗时的操作 可以添加Observer到主线程RunLoop中，通过监听RunLoop状态切换的耗时，以达到监控卡顿的目的 代码示例：LXDAppFluecyMonitor 耗电优化 尽可能降低CPU、GPU功耗 少用定时器 优化I/O操作 尽量不要频繁写入小数据，最好批量一次性写入 读写大量重要数据时，考虑用dispatch_io，其提供了基于GCD的异步操作文件I/O的API。用dispatch_io系统会优化磁盘访问 数据量比较大的，建议使用数据库（比如SQLite、CoreData） 网络优化 减少、压缩网络数据 如果多次请求的结果是相同的，尽量使用缓存 使用断点续传，否则网络不稳定时可能多次传输相同的内容 网络不可用时，不要尝试执行网络请求 让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间 批量传输，比如，下载视频流时，不要传输很小的数据包，直接下载整个 文件或者一大块一大块地下载。如果下载广告，一次性多下载一些，然后再慢慢展示。如果下载电子邮件，一次下载多封，不要一封一封地下载 定位优化 如果只是需要快速确定用户位置，最好用CLLocationManager的requestLocation方法。定位完成后，会自动让定位硬件断电 如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务 尽量降低定位精度，比如尽量不要使用精度最高的kCLLocationAccuracyBest 需要后台定位时，尽量设置pausesLocationUpdatesAutomatically为YES，如果用户不太可能移动的时候系统会自动暂停位置更新 尽量不要使用startMonitoringSignificantLocationChanges，优先考虑startMonitoringForRegion: 硬件检测优化 用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件 App的启动 APP的启动可以分为2种 冷启动（Cold Launch）：从零开始启动APP 热启动（Warm Launch）：APP已经在内存中，在后台存活着，再次点击图标启动APP APP启动时间的优化，主要是针对冷启动进行优化 通过添加环境变量可以打印出APP的启动时间分析（Edit scheme -&gt; Run -&gt; Arguments） DYLD_PRINT_STATISTICS设置为1 如果需要更详细的信息，那就将DYLD_PRINT_STATISTICS_DETAILS设置为1 App冷启动可以概括为3大阶段 dyld runtime main App启动 - dyld dyld（dynamic link editor），Apple的动态链接器，可以用来装载Mach-O文件（可执行文件、动态库等） 启动APP时，dyld所做的事情有 装载APP的可执行文件，同时会递归加载所有依赖的动态库 当dyld把可执行文件、动态库都装载完毕后，会通知Runtime进行下一步的处理 App启动 - runtime 启动APP时，runtime所做的事情有 调用map_images进行可执行文件内容的解析和处理 在load_images中调用call_load_methods，调用所有Class和Category的+load方法 进行各种objc结构的初始化（注册Objc类 、初始化类对象等等） 调用C++静态初始化器和__attribute__((constructor))修饰的函数 到此为止，可执行文件和动态库中所有的符号(Class，Protocol，Selector，IMP，…)都已经按格式成功加载到内存中，被runtime 所管理 App启动 - main APP的启动由dyld主导，将可执行文件加载到内存，顺便加载所有依赖的动态库 并由runtime负责加载成objc定义的结构 所有初始化工作结束后，dyld就会调用main函数 接下来就是UIApplicationMain函数，AppDelegate的application:didFinishLaunchingWithOptions:方法 App的启动优化 无用代码、无用的图片（资源）的删除 发挥多线程的优势 启动之后要显示的页面，尽量用纯代码写 业务逻辑的简化 二进制重排 启动优化通常指的都是pre-main的优化，按照不同的阶段可以大致分为 dyld 减少动态库、合并一些动态库（定期清理不必要的动态库） 减少Objc类、分类的数量、减少Selector数量（定期清理不必要的类、分类） 减少C++虚函数数量 Swift尽量使用struct runtime 用+initialize方法和dispatch_once取代所有的__attribute__((constructor))、C++静态构造器、ObjC的+load main 在不影响用户体验的前提下，尽可能将一些操作延迟，不要全部都放在finishLaunching方法中 按需加载 dylib loading - 动态库加载 优化：减少动态库的使用 rebase / binding - 偏移修正 / 符号绑定 偏移修正 在MachO二进制文件里函数的实现地址 eg：0x0001 运行到内存中，利用ASLR（安全机制随机的值） eg：0x1000 运行时：函数实现真实地址 = 0x0001 + 0x1000 = 0x1001 符号绑定 MachO文件存在磁盘当中，当程序运行时，通过laodImage镜像到内存中（copy） dyld进行符号绑定 优化：减少动态库的使用 ObjC setup - OC创建 initializer - load函数 &amp; 构造函数 二进制重排 将所有启动时需要调用的方法，排列在一起 - 二进制重排 安装包瘦身 安装包（IPA）主要由可执行文件、资源文件组成 资源（图片、音频、视频等） 采取无损压缩 去除没有用到的资源： https://github.com/tinymind/LSUnusedResources 可执行文件瘦身 编译器优化 Strip Linked Product、Make Strings Read-Only、Symbols Hidden by Default设置为YES 去掉异常支持，Enable C++ Exceptions、Enable Objective-C Exceptions设置为NO， Other C Flags添加-fno-exceptions 利用AppCode（https://www.jetbrains.com/objc/）检测未使用的代码：菜单栏 -&gt; Code -&gt; Inspect Code 编写LLVM插件检测出重复代码、未被调用的代码 LinkMap 生成LinkMap文件，可以查看可执行文件的具体组成（Build Settings -&gt; Linking -&gt; Path to Link Map File - 本地路径） 可借助第三方工具解析LinkMap文件： https://github.com/huanxsd/LinkMap 优化工具 WSL_FPS (FPS检测) LinkMap (每个文件大小) LSUnusedResources (无用的文件) appCode (同上) MLeaksFinder YYKit (异步渲染功能强大) 网络优化 循环引用 1.导致内存泄漏的几种方式？ 野指针 循环引用 强引用 非OC对象的影响 2.解决循环应用的方式？ __weak typeof(self) weakdSelf = self; 业务逻辑复杂的情况下，例如延迟操作容易引起对象提前释放，所以不建议这种方式 强引用、弱引用一起使用 self.name = @&quot;大宁宁&quot;; __weak typeof(self) weakSelf = self; self.block = ^{ __strong typeof(self) strongSelf = weakSelf; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ NSLog(@&quot;%@&quot;,strongSelf.name); // self - nil name - nil }); }; self.block(); 中间变量，将self设置为局部变量，再block结束时置为nil self.name = @&quot;大宁宁&quot;; __block LGViewController *vc = self; self.block = ^(){ dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ NSLog(@&quot;%@&quot;,vc.name); vc = nil; }); }; self.block(); 上一个方法改进（性能最高的一种方法） self.name = @&quot;大宁宁&quot;; self.blockVc = ^(LGViewController * vc) { dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ NSLog(@&quot;%@&quot;,vc.name); }); }; self.blockVc(self); 3.强引用 例如项目中遇到的NSTimer的使用，会导致强引用问题。（页面释放不掉，timer停不下来） @interface ViewController () @property (nonatomic, strong) NSTimer *timer; @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; self.timer = [NSTimer scheduledTimerWithTimeInterval:2 target:self selector:@selector(fireHome) userInfo:nil repeats:YES]; [self.timer fireDate]; } - (void)fireHome { NSLog(@&quot;来了&quot;); } - (void)dealloc{ [self.timer invalidate]; self.timer = nil; NSLog(@&quot;%s&quot;,__func__); } 第一种方法，调用iOS API - (void)didMoveToParentViewController:(UIViewController *)parent { if (parent == nil) { [self.timer invalidate]; self.timer = nil; } } 第二种方法，中间变量，利用创建一个临时变量target，打破self持有timer，则self会被释放，随即timer在析构函数里也可被释放 第三种方法，iOS已经优化过的timerblockAPI self.timer = [NSTimer scheduledTimerWithTimeInterval:2 repeats:YES block:^(NSTimer * _Nonnull timer) { NSLog(@&quot;来了来了&quot;); }]; [self.timer fireDate]; // 析构函数里释放掉timer即可 第四种方法，NSProxy，利用消息转发机制 内存泄漏检测方式 Xcode 设置Analyze during 'build' 为yes Instruement SDK MleakFind dealloc 自定义 MleakFind 目标：监听UIViewContrller是否发生内存泄漏，（只考虑 push、pop） 思路：我们在视图控制器弹出栈，并在这个视图完全销毁时，检测对象是否还活着 步骤： 1.交换视图控制器的viewWillAppear与swizzled_viewWillAppear方法，viewDidDisappear与swizzled_viewDidDisappear方法 2.使用关联方法，获取和设置视图控制进出栈状态 3.且在界面完全消失，并控制器的状态是出栈状态，这时，观察延时观察对象是否存活 ","link":"https://daning.netlify.app/post/xing-neng-you-hua/"},{"title":"iOS 卡顿、耗电等优化","content":"iOS 性能优化 屏幕成像原理 优化 CPU 优化 GPU 优化 耗电优化 启动优化 安装包瘦身 ] 什么是离屏渲染? ","link":"https://daning.netlify.app/post/ios-qia-dun-hao-dian-deng-you-hua/"},{"title":"OC 富文本添加多个图片","content":"富文本中计算多个占位符的range，然后替换成对应图片 用 ^^^^ 占位，然后逆序替换成对应的图片 NSString *note; NSArray *imageArr; if (_page_type == Outdoor_Guide_Page_Type_1) { note = LOCALSTRING(@&quot;1. Select a speaker as outdoor master speaker.\\n2. Long press “^^^^” button to enter outdoor master mode.&quot;); imageArr = @[@&quot;OutdoorGuide_btn_001&quot;]; } else { note = LOCALSTRING(@&quot;Long press “^^^^” button and “^^^^” on your expected speakers that would connected to outdoor master speaker.&quot;); imageArr = @[@&quot;OutdoorGuide_btn_001&quot;,@&quot;OutdoorGuide_btn_002&quot;]; } [self setupNoteLabel:note imageArray:imageArr]; - (void)setupNoteLabel:(NSString *)note imageArray:(NSArray *)imageArr { NSMutableArray *imgStrArr = [NSMutableArray array]; for (int i = 0; i &lt; imageArr.count; i++) { NSTextAttachment *textAttachment = [[NSTextAttachment alloc] init]; textAttachment.image = [UIImage imageNamed:imageArr[i]]; NSAttributedString *imgStr = [NSAttributedString attributedStringWithAttachment:textAttachment]; [imgStrArr addObject:imgStr]; } NSMutableParagraphStyle *pStyle = [[NSMutableParagraphStyle alloc]init]; pStyle.lineSpacing = 8; NSMutableAttributedString *noteStr = [[NSMutableAttributedString alloc] initWithString:note]; [noteStr addAttributes:@{NSForegroundColorAttributeName: THEME_LIGHT_COLOR, NSFontAttributeName: [UIFont systemFontOfSize:14], NSParagraphStyleAttributeName:pStyle} range:NSMakeRange(0, noteStr.length)]; // 正则匹配 占位符 NSString *regexStr = @&quot;(\\\\^\\\\^\\\\^\\\\^)&quot;; NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:regexStr options:0 error:nil]; NSArray *matches = [regex matchesInString:note options:0 range:NSMakeRange(0, note.length)]; NSMutableArray *rangeArr = [NSMutableArray array]; // 倒序获取 占位符ranges (防止正序替换的时候，由于图片replace后造成的整体location错误) [matches enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(NSTextCheckingResult *result, NSUInteger idx, BOOL * _Nonnull stop) { NSRange range = result.range; [rangeArr addObject:[NSValue valueWithRange:range]]; }]; // 替换 for (int i = 0; i &lt; rangeArr.count; i++) { NSValue *value = rangeArr[i]; NSRange range = value.rangeValue; [noteStr replaceCharactersInRange:range withAttributedString:imgStrArr[rangeArr.count - 1 - i]]; } _noteLabel.attributedText = noteStr; } ","link":"https://daning.netlify.app/post/oc-fu-wen-ben-tian-jia-duo-ge-tu-pian/"},{"title":"内存管理-Tagged Pointer","content":"从64bit开始，iOS引入了Tagged Pointer技术，用于优化NSNumber、NSDate、NSString等小对象的存储 概述 以NSNumber为例，在没有使用Tagged Pointer之前，NSNumber等对象需要动态分配内存、维护引用技术等，NSNumber指针存储的是堆中的NSNumber对象的地址值 在使用Tagged Pointer之后，NSNumber指针里面存储的数据变成了：Tag + Data，也就是将数据直接存储在了指针中 当指针不够存储数据时，才会使用动态分配内存的方式来存储数据 objc_msgSend能识别Tagged Pointer，比如NSNumber的intValue方法，直接从指针提取数据，节省了以前的调佣开销 例 以下述为例，第二个for循环，会在执行的时候crash！ dispatch_queue_t queue = dispatch_get_global_queue(0, 0); for (int i = 0; i &lt; 1000; i++) { dispatch_async(queue, ^{ self.testString = [NSString stringWithFormat:@&quot;abc&quot;]; }); } for (int i = 0; i &lt; 1000; i++) { dispatch_async(queue, ^{ self.testString = [NSString stringWithFormat:@&quot;abcdefghijk&quot;]; }); } 分析： ARC的实现原理其实就是MRC，在MRC中，代码类似如下，由于上面的例子中，会异步调用 [_testString release] ，因此会导致提前release导致崩溃； // 模拟MRC - (void)setTestString:(NSString *)testString{ if (_testString == testString) { [_testString release]; // 赋值为新对象前，先释放旧对象 _testString = [testString copy]; } } - (NSString *)testString{ return _testString; } - (void)dealloc{ [_testString release]; _testString = nil; [super deallco]; } 那么为什么 if (_testString == testString) 没有拦截住呢？ 是因为每次 [NSString stringWithFormat:@&quot;abcdefghijk&quot;] 时分配的地址都不一样！ 那么为什么 self.testString = [NSString stringWithFormat:@&quot;abc&quot;] 没有问题呢？ 这就是 Tagged Pointer 的原因了！这里RunTime 判断到 Tagged Pointer 后直接进行赋值，而根本没有调用 set 方法（强调一下这里每次 [NSString stringWithFormat:@&quot;abc&quot;] 的值是一样的） 如何判断是否为 Tagged Pointer 翻阅RunTime源码，可以查找到 _objc_isTaggedPointer 方法，我们以OC的方式模拟实现如下： // 如果是iOS平台 (指针的最 '高' 有效位是1，就是Tagged Pointer）) # define _OBJC_TAG_MASK (1UL&lt;&lt;63) // 如果是Mac平台（指针的最 '低' 有效位是1，就是Tagged Pointer） //# define _OBJC_TAG_MASK 1UL BOOL isTaggedPointer(id pointer){ return ((uintptr_t)pointer &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK; } - (void)taggerPointerTest{ NSString *str = [NSString stringWithFormat:@&quot;abcdefghijk&quot;]; NSString *str1 = [NSString stringWithFormat:@&quot;abc&quot;]; NSLog(@&quot;\\nstr - %p: isTaggedPointer: %d\\nstr1 - %p isTaggedPointer: %d&quot;,str,isTaggedPointer(str),str1,isTaggedPointer(str1)); } str - 0x600002660500: isTaggedPointer: 0 str1 - 0x81a8f3dc8fa2ffae isTaggedPointer: 1 ","link":"https://daning.netlify.app/post/nei-cun-guan-li-tagged-pointer/"},{"title":"内存管理-内存布局","content":"简述内存布局的基本规则 示意图 例 int a = 10; int b; - (void)test{ static int c = 20; static int d; int e; int f = 20; NSString *str = @&quot;test&quot;; NSObject *obj = [[NSObject alloc]init]; NSLog(@&quot;\\n&amp;a = %p\\n&amp;b = %p\\n&amp;c = %p\\n&amp;d = %p\\n&amp;e = %p\\n&amp;f = %p\\nstr = %p\\nobj = %p\\n&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f,str,obj); } // 内存地址从小到大排序 /** 字符串常量 str = 0x10dd440f8 已初始化的全局变量、静态变量 &amp;a = 0x10dd49d68 &amp;c = 0x10dd49d6c 未初始化的全局变量、静态变量 &amp;b = 0x10dd49f10 &amp;d = 0x10dd49ef0 堆 obj = 0x6000029f4230 栈 ↑ &amp;f = 0x7ff7b21bd658 &amp;e = 0x7ff7b21bd65c */ ","link":"https://daning.netlify.app/post/nei-cun-guan-li-nei-cun-bu-ju/"},{"title":"内存管理-GCD定时器","content":"NSTimer依赖于RunLoop。如果RunLoop的任务过于繁重，可能会导致NSTimer不准时； 所以我们有时就需要更准时的GCD定时器 基本使用方式 // 队列 dispatch_queue_t queue = dispatch_get_global_queue(0, 0); // 创建定时器 dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); // 设置时间 NSTimeInterval start = 2.0; // 2秒后开始 NSTimeInterval interval = 1.0; // 间隔 dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, start * NSEC_PER_SEC), interval * NSEC_PER_SEC, 0); // 设置回调 dispatch_source_set_event_handler(timer, ^{ NSLog(@&quot;currentThread %@&quot; ,[NSThread currentThread]); }); // 启动定时器 dispatch_resume(timer); self.gcdTimer = timer; // 需要用强引用保留此定时器对象 自定义封装 MyGCDTimer.h @interface MyGCDTimer : NSObject /// block 形式开启 task 任务 /// @param task task事件 /// @param start 几秒后开始 /// @param interval 时间间隔 /// @param repeats 是否重复 /// @param async 异步 or 同步 + (NSString *)doTask:(void(^)(void))task start:(NSTimeInterval)start interval:(NSTimeInterval)interval repeats:(BOOL)repeats async:(BOOL)async; /// target seletor 形式开始 task任务 + (NSString *)doTask:(id)target selector:(SEL)selector start:(NSTimeInterval)start interval:(NSTimeInterval)interval repeats:(BOOL)repeats async:(BOOL)async; + (void)cancelTask:(NSString *)taskName; @end MyGCDTimer.m @implementation MyGCDTimer static NSMutableDictionary *timers_; // timers 字典 {name : timer} static dispatch_semaphore_t semaphore_; // 信号量保证线程安全 + (void)initialize{ static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ timers_ = [NSMutableDictionary dictionary]; semaphore_ = dispatch_semaphore_create(1); }); } + (NSString *)doTask:(void (^)(void))task start:(NSTimeInterval)start interval:(NSTimeInterval)interval repeats:(BOOL)repeats async:(BOOL)async{ if (!task || start &lt; 0 || (interval &lt;= 0 &amp;&amp; repeats)) return nil; // 队列 dispatch_queue_t queue = async ? dispatch_get_global_queue(0, 0) : dispatch_get_main_queue(); // 创建定时器 dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); // 设置时间 dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, start * NSEC_PER_SEC), interval * NSEC_PER_SEC, 0); // 信号量保证线程安全 dispatch_semaphore_wait(semaphore_, DISPATCH_TIME_FOREVER); // 定时器唯一标识 NSString *name = [NSString stringWithFormat:@&quot;%zd&quot;,timers_.count]; // 存放到字典中(强引用) timers_[name] = timer; dispatch_semaphore_signal(semaphore_); // 设置回调 dispatch_source_set_event_handler(timer, ^{ task(); if (!repeats) { // 不重复则取消 [self cancelTask:name]; } }); // 启动定时器 dispatch_resume(timer); return name; } + (NSString *)doTask:(id)target selector:(SEL)selector start:(NSTimeInterval)start interval:(NSTimeInterval)interval repeats:(BOOL)repeats async:(BOOL)async{ if (!target || !selector) return nil; return [self doTask:^{ if ([target respondsToSelector:selector]) { [target performSelector:selector withObject:nil]; } } start:start interval:interval repeats:repeats async:async]; } + (void)cancelTask:(NSString *)taskName{ if (taskName.length == 0) return; dispatch_semaphore_wait(semaphore_, DISPATCH_TIME_FOREVER); dispatch_source_t timer = timers_[taskName]; if (timer) { dispatch_source_cancel(timer); [timers_ removeObjectForKey:taskName]; } dispatch_semaphore_signal(semaphore_); } @end 调用方式： @property (nonatomic, strong) dispatch_source_t gcdTimer; @property (nonatomic, copy) NSString *taskName; - (void)viewDidLoad { [super viewDidLoad]; self.taskName = [MyGCDTimer doTask:^{ NSLog(@&quot;currentThread %@&quot; ,[NSThread currentThread]); } start:2.0 interval:1.0 repeats:YES async:YES]; } - (void)dealloc{ NSLog(@&quot;%s&quot;,__func__); [MyGCDTimer cancelTask:_taskName]; } ","link":"https://daning.netlify.app/post/gcd-ding-shi-qi/"},{"title":"内存管理-定时器","content":"NSTimer在使用过程中可能会引发内存泄露，如何利用NSProxy来处理这个问题？ 场景 例如下述场景，我们希望在当前 viewController dealloc 后，自动销毁 NSTimer 和 CADisplayLink 的实例对象。 结论：无法执行 dealloc ，timer 和 displayLick 无法停止 - (void)viewDidLoad { [super viewDidLoad]; self.link = [CADisplayLink displayLinkWithTarget:self selector:@selector(test)]; [self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode]; _timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(test) userInfo:nil repeats:YES]; } - (void)test{ NSLog(@&quot;%s&quot;,__func__); } - (void)dealloc{ NSLog(@&quot;%s&quot;,__func__); [self.timer invalidate]; [self.link invalidate]; } 分析 CADisplayLink、NSTimer 会对 target 产生强引用，如果 target 又对它们产生了强引用，那么就会引发循环引用 解决方案 1. 提前手动释放 通常我们会在 viewWillDisappear 方法里 调用 [self.timer invalidate] 提前释放 timer 2. 自定义代理类 虽然手动管理很方便，但是不优雅，因此我们想从 强引用 的 target 入手，只要实现了弱引用，就可以打破这层循环；实现方式很简单，创建一个 协议类 ，协议类 弱引用 self，再将其传给 timer 的 target 即可； @interface DNProxy : NSObject @property (nonatomic, weak) id target; + (instancetype)proxyWithTarget:(id)target; @end @implementation DNProxy + (instancetype)proxyWithTarget:(id)target{ DNProxy *proxy = [[DNProxy alloc] init]; proxy.target = target; // 弱引用传进来的target return proxy; } // 由于NDProxy没有&quot;self&quot;对象的的实例方法，因此需要消息转发实现 self 的方法调用 - (id)forwardingTargetForSelector:(SEL)aSelector{ // 此处return _target后，会立刻进行 objc_msgSend(_target, aSelector); return _target; } @end 调用方式也很简单： _timer = [NSTimer scheduledTimerWithTimeInterval:1 target:[DNProxy proxyWithTarget:self] selector:@selector(test) userInfo:nil repeats:YES]; 3. NSProxy 和 方式2 很像，不过是系统自带的 NSProxy 类，专门用来处理类似的情况，虽然看起来比 方式2 要麻烦一点，但是实际上，我们略过了去父类中进行 方法查找 这一过程，不需要 动态方法解析，直接进行 方法签名 以及 方法调用 @interface MyProxy : NSProxy @property (nonatomic, weak) id target; + (instancetype)proxyWithTarget:(id)target; @end @implementation MyProxy + (instancetype)proxyWithTarget:(id)target{ // NSProxy对象不需要调用init，因为它本来就没有init方法 MyProxy *proxy = [MyProxy alloc]; proxy.target = target; // 弱引用传进来的target return proxy; } // 方法签名 - (NSMethodSignature *)methodSignatureForSelector:(SEL)sel{ return [_target methodSignatureForSelector:sel]; } // 调用 - (void)forwardInvocation:(NSInvocation *)invocation{ [invocation invokeWithTarget:_target]; } @end ","link":"https://daning.netlify.app/post/nei-cun-guan-li-ding-shi-qi/"},{"title":"ipa砸壳","content":"大致记录一下砸壳过程 当前环境 手机：iPhone 6 Plus ；iOS 12.5.5 macOS Monterey 12.0.1 Python 3.8.9 步骤 手机越狱 爱思助手有一键越狱，iPhone 6 Plus 在进行到 uncOver 软件操作的那一步时，需要开启飞行模式；当自动重启后Cydia被安装上了就是成功了！ frida 下载 手机Cydia：软件源-编辑-添加-https://build.frida.re-安装 mac 终端：sudo pip3 install frida-tools //安装frida sudo pip3 install frida //安装frida 配置frida-ios-dump环境 clone：git clone https://github.com/AloneMonkey/frida-ios-dump 或加速clone git clone https://hub.fastgit.org/AloneMonkey/frida-ios-dump.git pip3 install -r requirements.txt --ignore-installed six 配置相关环境 USB连接 brew安装usbmuxd，usbmuxd自带工具iproxy，iproxy可以快捷连接iPhone操作 iproxy 2222 22 //执行如下命令把当前连接设备的22端口(SSH端口)映射到电脑的2222端口，那么想和设备22端口通信，直接和本地的2222端口通信就可以 Cydia 安装 openSSH，另开终端进程ssh -p 2222 root@127.0.0.1 // 默认密码：alpine 砸壳 python3 dump.py -l //查看所有app获取对应bundleID python3 dump.py bundleID //执行完成在当前目录生成ipa otool -l XXX | grep crypt //查看是否脱壳，0为已经脱壳 ","link":"https://daning.netlify.app/post/ipa-za-ke/"},{"title":"Xcode 警告消除","content":"维护老旧项目时，由于版本过低，导致大量的warning影响编译速度，以下是忽略警告的方式 步骤 找到buildtime中，想要忽略的警告类型，并右键 选中 &quot; Reveal in Log &quot; 我们可以看到代表开启的flag为 &quot;-Wunreachable-code&quot; 其中 “-W” 代表开启，关闭则为 “-Wno-” : “-Wno-unreachable-code” Build Setting -&gt; Other Warning Flags 里 添加 “-Wno-unreachable-code” 即可消除此类警告 Flags 类型 Flag Code will never be executed -Wno-unreachable-code 过期方法 -Wno-deprecated-declarations 实例化，未使用 -Wno-unused-variable nonnull警告 -Wno-nullability-completeness ","link":"https://daning.netlify.app/post/xcode-jing-gao-xiao-chu/"},{"title":"Mac iTerm命令行编辑快捷键","content":"仅在 iTerm 上 搭配 zsh 使用 编辑命令行 操作 指令 跳到行首 Ctrl+a 跳到行尾 Ctrl+e 删除光标前一个单词（根据空格识别单词分隔） Ctrl+w 删除光标前所有内容 Ctrl+Shift+u 清屏 Ctrl+l / Cmd+k 历史记录 Ctrl+r zshrc里配置 vim ~/.zshrc 编辑添加 操作 添加指令 指令 光标后退一个单词 bindkey '^B' backward-word Ctrl+b 光标前进一个单词 bindkey '^F' forward-word Ctrl+f ","link":"https://daning.netlify.app/post/mac-zhong-duan-ming-ling-xing-bian-ji-kuai-jie-jian/"},{"title":"Swift 获取 当前 键盘","content":"场景是，改变textField弹出键盘的frame 话不多说，直接上代码 // 点击获取当前屏幕上展示的键盘，没有就置空 @IBAction func buttonAction(_ sender: Any) { keyBoardBackView = getKeyBoard() } // 移动获取到的键盘 @IBAction func moveAction(_ sender: Any) { if keyBoardBackView != nil { if var bounds = keyBoardBackView?.bounds { bounds.origin.y -= 20; keyBoardBackView?.bounds = bounds } } } /** 目前可以肯定的是，UIKeyBoard展示出来的时候，它的结构再不同的iOS版本上肯定是不同的， 我不知道是哪个版本之后，结构才像我现在这么解析的这种，我是一层层看视图找到的，所以要注意2点： 1. 不同的iOS版本，这个遍历获取keyBoardBackView的 keyPath 问题 2. 横竖屏问题 */ func getKeyBoard() -&gt; UIView? { // UIApplication.shared.windows iOS15之后改写法了 let windows = UIApplication.shared.windows for window in windows.reversed() { let keyBoardWindow:AnyClass? = NSClassFromString(&quot;UIRemoteKeyboardWindow&quot;) if window.isKind(of: keyBoardWindow!) { // 键盘是放在 主window 的同级另一个 window下的 let keyBoard = getKeyBoardInView(window) return keyBoard } } return nil } func getKeyBoardInView(_ view:UIView) -&gt; UIView? { for subView in view.subviews { let containerView:AnyClass? = NSClassFromString(&quot;UIInputSetContainerView&quot;) let inputSetHostView:AnyClass? = NSClassFromString(&quot;UIInputSetHostView&quot;) if subView.isKind(of: containerView!) { // 键盘Window controll的 的 主View return getKeyBoardInView(subView); // 继续往下一层查 } else if subView.isKind(of: inputSetHostView!) { // 这个View 就是 keyBoard 的 BackView print(&quot;找到了&quot;) subView.backgroundColor = UIColor.red return subView } } return nil } ","link":"https://daning.netlify.app/post/swift-huo-qu-dang-qian-jian-pan/"},{"title":"ClashX配置","content":"记录下如何用Mac上如何用ClashX搭梯子吧 1. 安装 直接去Github下载最新的Release版本: ClashX Github Release 2. 流量套餐购买 我是使用的 AgentNEO ，挺傻瓜式的，主要经历了几步 进入 AgentNEO 主页：AgentNEO 不用瞎寻思，充钱就行 3. Mac端配置 可以通过自动导入，或者手动添加，最终都是在管理页面添加配置 3.1 自动配置： 【我的服务】-【购买的套餐】-【配置下载(订阅)】-【Clash 配置链接】-&gt; 直接一键导入即可自动配置ClashX的配置框 3.2 手动配置： 同上面的流程，最后选择复制地址，然后到Mac状态栏找到Clash，接下来【配置】-【托管配置】-【管理】- 手动添加 3.3 开启&amp;关闭 点击 ClashX 状态栏图标，将【出站模式】选为【规则判断】，在【Proxy】中可以选择自己喜欢的线路后，并将 FINAL 设置为【DIRECT】防止代理不必要的网站。点击【设置为系统代理】即可开始使用。 如果取消使用，推荐先取消勾选【设置为系统代理】，然后再退出ClashX 4. iPhone端配置 4.1 安装Shadowrocket ipa包：网盘链接: https://pan.baidu.com/s/1m2NHI_6nwVJMOF11R3RBdA 密码: lq2f 如果上述文件无法使用，那么只能搞个国外的AppleIID下载了，不过是收费软件 4.2 配置 可以参照3.1、3.2的方式配置，不过手机上有个二维码方式导入很方便，已经添加过的人，直接在Shadowrocket中的节点配置左滑，可以有生成二维码选项，其他想使用的人，直接扫这个二维码就可以直接导入相同的配置 ","link":"https://daning.netlify.app/post/clashx-pei-zhi/"},{"title":"多线程简介","content":"简单介绍下 多线程的基本概念、GCD、iOS中的线程同步方案、iOS中的读写安全方案 1. 基本概念 iOS中常见多线程方案 2. GCD GCD的常用函数 GCD中有2个用来执行任务的函数： 用同步的方式执行任务 dispatch_sync(dispatch_queue_t queue, dispatch_block_t block); 用异步的方式执行任务 dispatch_async(dispatch_queue_t queue, dispatch_block_t block); GCD的队列 GCD的队列可以分为2大类型 并发队列（Concurrent Dispatch Queue） 可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务） 并发功能只有在异步（dispatch_async）函数下才有效 串行队列（Serial Dispatch Queue） 让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务） 容易混淆的术语 有4个术语比较容易混淆：同步、异步、并发、串行 同步和异步主要影响：能不能开启新的线程 同步：在当前线程中执行任务，不具备开启新线程的能力 异步：在新的线程中执行任务，具备开启新线程的能力 并发和串行主要影响：任务的执行方式 并发：多个任务并发（同时）执行 串行：一个任务执行完毕后，再执行下一个任务 各种队列的执行效果 使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）, 如：sync 在等待 test 执行结束，test 在等待 sync 任务执行，产生死锁- (void)test{ NSLog(@&quot;任务1&quot;)； dispatch_sync(dispatch_get_main_queue(), ^{ NSLog(@&quot;任务2&quot;)； }); NSLog(@&quot;任务3&quot;)； } 队列组 队列组可以实现异步并发执行任务1、任务2，等任务1、任务2都执行完毕后，再回到主线程执行任务3 多线程的安全隐患 &amp; 解决方案 多线程的安全隐患 资源共享 1块资源可能会被多个线程共享，也就是“多个线程可能会访问同一块资源” 比如多个线程访问同一个对象、同一个变量、同一个文件 当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题 解决方案 使用线程同步技术（同步，就是协同步调，按预定的先后次序进行） 常见的线程同步技术是：加锁 3 iOS中的线程同步方案 1. OSSpinLock (自旋锁) 2. os_unfair_lock (互斥锁；根据底层代码逻辑，加锁时是休眠线程，跟自旋锁不同，所以认为是互斥锁) 3. pthread_mutex (互斥锁) 4. dispatch_semaphore 5. dispatch_queue(DISPATCH_QUEUE_SERIAL) 6. NSLock、NSRecursiveLock 7. NSCondition、NSConditionLock 8. @synchronized 1. OSSpinLock OSSpinLock叫做”自旋锁”，等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源 iOS 已不再推荐使用，已被 os_unfair_lock 替代 目前已经不再安全，可能会出现优先级反转问题 如果等待锁的线程优先级较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁 需要导入头文件#import &lt;libkern/OSAtomic.h&gt; 2. os_unfair_lock os_unfair_lock用于取代不安全的OSSpinLock ，从iOS10开始才支持 从底层调用看，等待os_unfair_lock锁的线程会处于休眠状态，并非忙等 需要导入头文件#import &lt;os/lock.h&gt; 3. pthread_mutex mutex叫做”互斥锁”，等待锁的线程会处于休眠状态 需要导入头文件#import &lt;pthread.h&gt; pthread_mutex – 递归锁 pthread_mutex – 条件 4. dispatch_semaphore semaphore叫做”信号量” 信号量的初始值，可以用来控制线程并发访问的最大数量 信号量的初始值为1，代表同时只允许1条线程访问资源，保证线程同步 5. dispatch_queue 直接使用GCD的串行队列，也是可以实现线程同步的 6. NSLock、NSRecursiveLock NSLock是对mutex普通锁的封装 NSRecursiveLock也是对mutex递归锁的封装，API跟NSLock基本一致 7. NSCondition、 NSConditionLock NSCondition是对mutex和cond的封装 NSConditionLock是对NSCondition的进一步封装，可以设置具体的条件值 8. @synchronized @synchronized是对mutex递归锁的封装 @synchronized(obj)内部会生成obj对应的递归锁，然后进行加锁、解锁操作 简洁 但是 比较 耗内存 @synchronized(obj){ // 任务 } iOS线程同步方案性能比较 性能从高到低排序 os_unfair_lock OSSpinLock dispatch_semaphore pthread_mutex dispatch_queue(DISPATCH_QUEUE_SERIAL) NSLock NSCondition pthread_mutex(recursive) NSRecursiveLock NSConditionLock @synchronized 自旋锁、互斥锁比较 什么情况使用自旋锁比较划算？ 预计线程等待锁的时间很短 加锁的代码（临界区）经常被调用，但竞争情况很少发生 CPU资源不紧张 多核处理器 什么情况使用互斥锁比较划算？ 预计线程等待锁的时间较长 单核处理器 临界区有IO操作 临界区代码复杂或者循环量大 临界区竞争非常激烈 4 iOS中的读写安全方案 思考如何实现以下场景 同一时间，只能有1个线程进行写的操作 同一时间，允许有多个线程进行读的操作 同一时间，不允许既有写的操作，又有读的操作 上面的场景就是典型的“多读单写”，经常用于文件等数据的读写操作，iOS中的实现方案有 pthread_rwlock：读写锁 dispatch_barrier_async：异步栅栏调用 pthread_rwlock 等待锁的线程会进入休眠 dispatch_barrier_async 这个函数传入的并发队列必须是自己通过dispatch_queue_cretate创建的 如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于dispatch_async函数的效果 ","link":"https://daning.netlify.app/post/duo-xian-cheng-jian-jie/"},{"title":"RunLoop","content":"RunLoop 相关 简介 基本作用 保持程序的持续运行 处理APP中的各种事件（比如触摸事件、定时器事件等） 节约CPU性能，提高程序性能；该做事时做事，该休息时休息 ..... RunLoop对象 iOS中有2套API来访问和使用RunLoop Foundation：NSRunLoop Core Foundation：CFRunLoopRef 获取当前RunLoop NSRunLoop *runloop = [NSRunLoop currentRunLoop]; // OC CFRunLoopRef runloop2 = CFRunLoopGetCurrent(); // C NSRunLoop和CFRunLoopRef都代表着RunLoop对象，NSRunLoop是基于CFRunLoopRef的一层OC包装； CFRunLoopRef是开源的 ：https://opensource.apple.com/tarballs/CF/ RunLoop与线程 每条线程都有唯一的一个与之对应的RunLoop对象 RunLoop保存在一个全局的Dictionary里，线程作为key，RunLoop作为value 线程刚创建时并没有RunLoop对象，RunLoop会在第一次获取它时创建 RunLoop会在线程结束时销毁 主线程的RunLoop已经自动获取（创建），子线程默认没有开启RunLoop 获取RunLoop对象 //Foundation [NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象 [NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象 //Core Foundation CFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象 CFRunLoopGetMain(); // 获得主线程的RunLoop对象 RunLoop相关的类 CFRunLoopModeRef CFRunLoopModeRef代表RunLoop的运行模式 一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0/Source1/Timer/Observer RunLoop启动时只能选择其中一个Mode，作为currentMode 如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入；不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响 如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出 常见的2种Mode kCFRunLoopDefaultMode（NSDefaultRunLoopMode）：App的默认Mode，通常主线程是在这个Mode下运行 UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响 CFRunLoopObserverRef 添加Observer监听RunLoop的所有状态 RunLoop的运行逻辑 线程保活 DNPermenantTheread.h @interface DNPermenantTheread : NSObject /// 开启线程 - (void)run; /// 执行任务 /// @param task 任务 - (void)executeTask:(void(^)(void))task; /// 关闭线程 - (void)stop; @end DNPermenantTheread.m #import &quot;DNPermenantTheread.h&quot; #import &lt;objc/runtime.h&gt; @interface DNPermenantTheread() @property (nonatomic, assign, getter=isStopped) BOOL stopped; @property (nonatomic, strong) NSThread *innerThread; @end @implementation DNPermenantTheread - (instancetype)init{ if (self = [super init]) { self.stopped = NO; __weak typeof(self) weakSelf = self; self.innerThread = [[NSThread alloc] initWithBlock:^{ [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc]init] forMode:NSDefaultRunLoopMode]; while (weakSelf &amp;&amp; !weakSelf.isStopped) { [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate: [NSDate distantFuture]]; } }]; } return self; } #pragma mark - public methods - (void)run{ if (!_innerThread) return; [self.innerThread start]; } - (void)executeTask:(void(^)(void))task{ if (!_innerThread || !task) return; [self performSelector:@selector(__executeTask:) onThread:self.innerThread withObject:task waitUntilDone:NO]; } - (void)stop{ if (!_innerThread) return; [self performSelector:@selector(__stop) onThread:self.innerThread withObject:nil waitUntilDone:YES]; } #pragma mark - private methods - (void)__stop{ self.stopped = YES; CFRunLoopStop(CFRunLoopGetCurrent()); } - (void)__executeTask:(void(^)(void))task{ task(); } @end ","link":"https://daning.netlify.app/post/runloop/"},{"title":"Runtime-API","content":"列举部分常见的runtime API; OC是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行 OC的动态性就是由Runtime来支撑和实现的，Runtime是一套C语言的API，封装了很多动态性相关的函数 类 // 动态创建一个类（参数：父类，类名，额外的内存空间） Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes) // 注册一个类（要在类注册之前添加成员变量） void objc_registerClassPair(Class cls) // 销毁一个类 void objc_disposeClassPair(Class cls) // 获取isa指向的class Class object_getClass(id obj) // 设置isa指向的Class Class object_setClass(id obj, Class cls) // 判断一个OC对象是否为Class BOOL object_isClass(id obj) // 判断一个Class是否为元类 BOOL class_isMetaClass(Class cls) // 获取父类 Class class_getSuperClass(Class cls) 成员变量 // 获取一个示例变量信息 Ivar class_getInstanceVariable(Class cls, contst char *name) // 拷贝实例变量列表（最后需要调用free释放） Ivar *class_copyIvarList(Class cls, unsigned int *outCount) // 设置和获取成员变量的值 void object_setIvar(id obj, Ivar ivar, id value) id object_getIvar(id pbj, Ivar ivar) // 动态添加成员变量（已注册的类是不能动态添加成员变量的） BOOL class_addIvar(Class cls, const char * name, size_t size, uint8_t alignment, const char * types) // 获取成员变量的相关信息 const char *ivar_getName(Ivar v) const char *ivar_getTypeEncoding(Ivar v) 属性 // 获取一个属性 objc_property_t class_getProperty(Class cls, const char *name) // 拷贝属性列表（最后需要调用free释放） objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount) // 动态添加属性 BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount) // 动态替换属性 void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount) // 获取属性的一些信息 const char *property_getName(objc_property_t property) const char *property_getAttributes(objc_property_t property) 方法 // 获得一个实例方法、类方法 Method class_getInstanceMethod(Class cls, SEL name) Method class_getClassMethod(Class cls, SEL name) // 方法实现相关操作 IMP class_getMethodImplementation(Class cls, SEL name) IMP method_setImplementation(Method m, IMP imp) void method_exchangeImplementations(Method m1, Method m2) // 拷贝方法列表（最后需要调用free释放） Method *class_copyMethodList(Class cls, unsigned int *outCount) // 动态添加方法 BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types) // 动态替换方法 IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types) // 获取方法的相关信息（带有copy的需要调用free去释放） SEL method_getName(Method m) IMP method_getImplementation(Method m) const char *method_getTypeEncoding(Method m) unsigned int method_getNumberOfArguments(Method m) char *method_copyReturnType(Method m) char *method_copyArgumentType(Method m, unsigned int index) // 选择器相关 const char *sel_getName(SEL sel) SEL sel_registerName(const char *str) // 用block作为方法实现 IMP imp_implementationWithBlock(id block) id imp_getBlock(IMP anImp) BOOL imp_removeBlock(IMP anImp) ","link":"https://daning.netlify.app/post/runtime-api/"},{"title":"objc_msgSend的执行流程","content":"Runtime最核心的东西，objc_msgSend 执行流程 OC中的方法调用，其实都是转换为objc_msgSend函数的调用 objc_msgSend的执行流程可以分为3大阶段 消息发送 动态方法解析 示例 消息转发 示例 ","link":"https://daning.netlify.app/post/objc_msgsend/"},{"title":"Class方法缓存：cache_t","content":"简单了解一下，OC在调用方法的时候，底层的实现逻辑是什么？ 首先我们窥探下struct objc_class的结构 Class内部结构中有个方法缓存（cache_t），用**散列表(哈希表)**来缓存曾经调用过的方法，可以提高方法的查找速度 散列表：以空间来换时间（根据得出的index进行分配地址，即可能存在未使用的地址）；根据 _key 和 _mask 进行位运算 得出 index （_key &amp; _mask -&gt; index）；如果未被占用，则使用，如已被占用，则重新生成 （大致思路：i ? i - 1 : mask） ","link":"https://daning.netlify.app/post/class-fang-fa-huan-cun-cache_t/"},{"title":"isa指针在64位系统后为什么要用位域方式去计算？","content":"在arm64架构之前，isa就是一个普通的指针，存储着Class、Meta-Class对象的内存地址； 从arm64架构开始，对isa进行了优化，变成了一个共用体 &quot;union&quot; 结构，还使用位域来存储更多的信息。 所以，为什么要使用这种方式来优化呢？ 首先我们看下64位系统下isa指针的结构 结论：使用共用体 union，可以在有限的空间内，同样是8个字节，我们可以存储更多的信息 我们以Person对象为例，来逐步了解 isa 使用 union 的优化方式； 1. 普通的Person对象 我们以Person这个对象为例:假设它有3个成员变量，tail、rich、handsome，那么正常情况下它需要占用16个字节； @interface Person : NSObject @property (nonatomic, assign) BOOL tall; @property (nonatomic, assign) BOOL rich; @property (nonatomic, assign) BOOL handsome; @end 3个成员变量占用3个字节，isa指针占用8个字节，所以一共占用11个字节，内存对齐后，总共占用16个字节 NSLog(@&quot;正常的 Person 对象占用：%zd 个字节&quot;,class_getInstanceSize([Person class])); // 输出：正常的 Person 对象占用：16 个字节 2. 以位运算的方式优化 1个成员变量_tallRichHandsome 占用1个字节，isa指针8个字节，内存对其后，总共占用16个字节； 我们不声明其成员变量，直接创建对应的方法; @interface Person : NSObject - (void)setTall:(BOOL)tall; - (void)setRich:(BOOL)rich; - (void)setHandsom:(BOOL)handsome; - (BOOL)isTall; - (BOOL)isRich; - (BOOL)isHandsome; @end 声明一个char类型的对象，用来按位存储tall、rich、handsome @interface Person(){ char _tallRichHandsome; // 0b 0000 0111 ; 占1个字节 } @end 通过位运算，实现set、get方法 #define TallMask (1&lt;&lt;0) // 0000 0001 (掩码) #define RichMask (1&lt;&lt;1) // 0000 0010 #define HandsomeMask (1&lt;&lt;2) // 0000 0100 @interface Person(){ char _tallRichHandsome; // 0b 0000 0111 ; 占1个字节 } @end @implementation Person - (void)setTall:(BOOL)tall{ if (tall) { _tallRichHandsome |= TallMask; // 按位或 } else { _tallRichHandsome &amp;= ~TallMask; // 取反后按位与 } } - (void)setRich:(BOOL)rich{ // 同setTall方法... } - (void)setHandsome:(BOOL)handsome{ // 同setTall方法... } // 跟掩码进行与运算，再取2次反后，结果即为期待值（只要大于0，则为YES） - (BOOL)isTall{ return !!(_tallRichHandsome &amp; TallMask); } - (BOOL)isRich{ return !!(_tallRichHandsome &amp; RichMask); } - (BOOL)isHandsome{ return !!(_tallRichHandsome &amp; HandsomeMask); } @end 3. 利用结构体继续优化 (位域) 利用结构体 代替 char类型的 _tallRichHandsome，然后利用位域，保证_tallRichHandsome仅占1个字节（不然的话，每个char都占1个字节，一共又占用3个字节了）； @interface Person(){ struct { char tall : 1; // :1 位域，代表只占1位 char rich : 1; char handsome : 1; } _tallRichHandsome; // 按照先后顺序从右向左排 0b 0000 0000 } @end @implementation Person - (void)setTall:(BOOL)tall{ _tallRichHandsome.tall = tall; } - (void)setRich:(BOOL)rich{ _tallRichHandsome.rich = rich; } - (void)setHandsome:(BOOL)handsome{ _tallRichHandsome.handsome = handsome; } - (BOOL)isTall{ return _tallRichHandsome.tall; } - (BOOL)isRich{ return _tallRichHandsome.rich; } - (BOOL)isHandsome{ return _tallRichHandsome.handsome; } @end 此时输出，会发现BOOL输出了-1，打断点发现其为255； 原因是 tall 只占1个二进制位，即为0b1，return tall 的时候，强制转为 8位 的 BOOL 类型，程序会默认按照自己的规则转，结果转成了 0b 1111 1111 （255），最高位为1，所以为 -1 的补码，所以输出了 -1 （减1后得反码，再取反后得原码） Person *person = [[Person alloc] init]; person.tall = YES; person.rich = YES; person.handsome = NO; NSLog(@&quot;tall: %d ; rich: %d ; handsome: %d&quot;,person.isTall,person.isRich,person.isHandsome); // tall: -1 ; rich: -1 ; handsome: 0 BOOL isTall = person.isTall; // 255 解决方式为： - (BOOL)isTall{ return !!_tallRichHandsome.tall; // 取值的时候，2次取反即可 } 4. 用 union 共用体 优化 因为共用体内共用同一块内存，所以 bits 和 struct 结构体 共用 他们最大的内存：1个字节；实际上和 &quot;2. 以位运算的方式优化&quot; 是一样的 @interface Person(){ union { // 共用体 char bits; struct { // 增加可读性，无任何作用，删除也不影响结果 char tall : 1; char rich : 1; char handsome : 1; }; } _tallRichHandsome; } @end @implementation Person - (void)setTall:(BOOL)tall{ if (tall) { _tallRichHandsome.bits |= TallMask; } else { _tallRichHandsome.bits &amp;= ~TallMask; } } - (void)setRich:(BOOL)rich{ // 同setTall方法... } - (void)setHandsome:(BOOL)handsome{ // 同setTall方法... } - (BOOL)isTall{ return !!(_tallRichHandsome.bits &amp; TallMask); } - (BOOL)isRich{ return !!(_tallRichHandsome.bits &amp; RichMask); } - (BOOL)isHandsome{ return !!(_tallRichHandsome.bits &amp; HandsomeMask); } @end ","link":"https://daning.netlify.app/post/isa-zhi-zhen-zai-64-wei-xi-tong-hou-wei-shi-me-yao-yong-wei-yu-fang-shi-qu-ji-suan/"},{"title":"终端-效率工具","content":"记录一下终端上能提高效率的工具 1 搜索代码神器-Ag Ag是一个比grep、ack更快的递归搜索文件内容的工具。 CSDN文档、简书文档 安装 brew install the_silver_searcher Ag 语法 $ ag 参数选项 关键字 常用参数： i 忽略大小写 g 文件名匹配 l 列出文件名 --php 只搜索php文件 --ignore-dir 忽略目录 ","link":"https://daning.netlify.app/post/zhong-duan-xiao-lu-gong-ju/"},{"title":"解决Github访问速度慢的问题","content":"通过修改hosts文件，改变github的映射IP。 发现这样改貌似会影响git push，而且访问时灵时不灵，因此目前已放弃！！！ 步骤 打开hosts文件，编辑完毕后:wq保存退出即可 sudo vim /etc/hosts 修改Github相关配置 追加下面映射关系 140.82.112.4 github.com 199.232.69.194 github.global.ssl.fastly.net 刷新DNS缓存(可不执行) 可以先 ping github.com 看看ip是否已经更改成功，如果还未更新，可以刷新DNS dscacheutil -flushcache 说明 映射关系的IP可以通过 https://www.ipaddress.com/ 查询 也可以通过 http://ping.chinaz.com 查询 ","link":"https://daning.netlify.app/post/jie-jue-github-fang-wen-su-du-man-de-wen-ti/"},{"title":"block的内存管理&循环引用","content":" 内存管理 当block在栈上时，并不会对__block/__weak变量产生强引用 当block被copy到堆上时 会调用block内部的copy函数 copy函数内部会调用 _Block_object_assign 函数 (__block变量/OC对象 传入参数不同) _Block_object_assign 函数会对__block变量形成强引用 (retain)；对__weak变量形成弱引用 当block从堆中移除时 会调用block内部的dispose函数 dispose函数内部会调用 _Block_object_dispose 函数 (__block变量/OC对象 传入参数不同) _Block_object_dispose 函数会自动释放引用的__block/__weak变量 (release) 循环引用 循环引用示例 person对象不会释放，因为person对象持有着block，block又强引用着person对象； { MJPerson *person = [[MJPerson alloc] init]; person.age = 10; person.block = ^{ NSLog(@&quot;%d&quot;,person.age); }; } // 作用域结束后，person并不会被释放 此例子self对象本身也不会被释放，self本身实际上是一个局部变量，是作为参数传递进方法里的，循环引用的原理同上；（_age 实际上是 self-&gt;_age，同样引用了self） -(void)test{ self.block = ^{ NSLog(@&quot;age is %d - %d&quot;, self.age, _age); } } ","link":"https://daning.netlify.app/post/block-de-nei-cun-guan-li-andxun-huan-yin-yong/"},{"title":"block的本质","content":"目录：block的本质、变量捕获、类型、copy、__block修饰符 本质 block本质上也是一个OC对象，它内部也有个isa指针 block是封装了函数调用（函数地址）以及函数调用环境（参数、外部局部变量等）的OC对象 图示： 变量捕获 局部变量 类型 捕获到block内部 访问问方式 auto ✅ 值传递 static ✅ 指针传递 auto int age = 10; // auto: 自动变量，离开作用域就销毁 static int height = 100; void (^block)(void) = ^{ NSLog(@&quot;age is %d, height is %d&quot;,age ,height); // 捕获变量(capture) }; age = 20; height = 200; block(); // age is 10, height is 200 全局变量 类型 捕获到block内部 访问问方式 全局变量 ❌ 直接访问 self self也会被捕获到block内部，注意，self实际上是局部变量！！！指针传递 oc当中，函数方法实际上有2个隐藏参数，例（MyPerson *self，SEL _cmd），其中，self是作为局部变量传递进来的 block的类型 block有3种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型。 NSGlobalBlock ( _NSConcreteGlobalBlock ) 没有访问auto变量的 NSStackBlock ( _NSConcreteStackBlock ) 访问了auto变量(需在非ARC) NSMallocBlock ( _NSConcreteMallocBlock ) NSStackBlock 调用了copy(需在非ARC) 每一种类型的block调用copy后的结果如下： block类型 副本源的配置存储域 复制效果 NSGlobalBlock 程序的数据区域 什么也不做 NSStackBlock 栈 从栈复制到堆 NSMallocBlock 堆 引用计数增加 block的copy 在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上，比如： blcok作为函数返回值时 MJBlock block() { int age = 10; return ^{ NSLog(@&quot;age = %d&quot;,age); }; } 将block赋值给 __strong 指针时 int age = 10; void (^blcok)(void) = ^{ NSLog(@&quot;age = %d&quot;,age); }; block(); block作为Cocoa API中方法名含有usingBlock的方法参数时 block作为GCD API的方法参数时 __block修饰符 作用： __block可以用于解决block内部无法修改auto变量值的问题 __block不能修饰全局变量、静态变量 编译器会将__block变量包装成一个对象 内存管理： 当block在栈上时，并不会对 __block 产生强引用 当block被copy到堆时，会调用block内部的copy函数，其内部会对 __block 变量形成强引用 当block从堆中移除时，会调用block内部的dispose函数，其内部会自动释放引用的 __block 变量（release） ","link":"https://daning.netlify.app/post/block-de-ben-zhi/"},{"title":"Category分类","content":"了解Category、关联对象的原理 Category的实现原理 Category编译之后的底层结构是struct category_t , 里面储存着分类的对象方法、类方法、属性、协议信息 在程序运行的时候，runtime会将Category的数据合并到类信息中（类对象，元类对象中） 在合并过程中，是先根据分类的数量拓展对应的内存，然后将类对象的method_list内存地址往后移动对应的长度，再将分类的method_list拷贝至前面空出的内存区(拷贝顺序按照编译顺序来，越晚编译，内存地址越靠前)，所以相同的方法，会先执行分类中的方法（跟继承有本质的区别）； Category和ClassExtension的区别是什么？ Class Extentsion在编译的时候，它的数据就已经包含再类信息中 Category是在运行时，才会将数据合并到类信息中 Category中的load方法是什么时候调用的？ load方法再runtime加载类、分类的时候调用 load方法可以继承，但是一般情况下不会主动去调用load方法，都是让系统自动调用。 Category能否添加成员变量？ 不能直接添加，但是可以间接实现Category有成员变量的效果 利用runtime实现 objc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key) objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key, id _Nullable value, objc_AssociationPolicy policy) 关联对象 本质 修饰符的含义 为什么没有weak修饰？ 因为ObjectAssociation指向的_value不是弱引用，这样可以防止坏内存访问 ","link":"https://daning.netlify.app/post/category-fen-lei/"},{"title":"KVC原理","content":"图示KVC赋值、取值的原理 KVC赋值的原理 KVC取值的原理 通过KVC修改成员变量会触发KVO吗？ 答案是 【会】 触发; 无论是否存在set方法，都会触发KVO； 即便没有set方法，KVC也会在内部调用will/didChangeValueForKey ","link":"https://daning.netlify.app/post/kvc-yuan-li/"},{"title":"KVO的本质","content":"简单了解KVO底层的实现逻辑 示例代码 OC当中的KVO使用起来很简单，简单3个步骤就可以完成对一个对象的成员变量的监听; 假如我们想监听Persen对象的age属性： // 1.给Person对象添加KVO监听 NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld; [self.person addObserver:self forKeyPath:@&quot;age&quot; options:options context:@&quot;123&quot;]; // 2. 监听对象的属性发生改变时的回调函数 - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context{} // 3.移除监听 [self.person removeObserver:self forKeyPath:@&quot;age&quot;]; KVO实现的本质 依然以Persen对象为例，正常情况下，self.person这个实例对象的isa指针，指向的应该是Person这个类对象；但是当给其添加KVO监听后，会在self.person这个instance对象和Person class对象之间，生成一个Person class的子类NSKVONotifying_Person；这时实例对象的isa指针，就会更改为指向NSKVONotifying_Person这个class对象； NSKVONotifying_Person是Runtime动态创建的一个类，是Person的子类; 其内部包含class方法，返回值可能为[Person class]父类class 那么NSKVONotifying_Person是如何实现监听的过程呢？ // 以下均为伪代码，方便理解 - (void)setAge:(int)age { // 在执行set方法时，会调用c函数中的下面这个方法 _NSSetIntValueAndNotify(); // 当然不仅仅有int的方法，char、long long、double...都有 } void _NSSetIntValueAndNotify() { [self willChangeVlaueForKey:@&quot;age&quot;]; [super setAge:age]; // 调用父类Person的setAge方法 [self didChangeValueForKey:@&quot;age&quot;]; } - (void)didChangeValueForKey:(NSString *)key { // 通知监听器，属性值发生了改变 [observer observeValueForKeyPath: key ofObject:self change:change context:nil]; } ","link":"https://daning.netlify.app/post/kvo-de-ben-zhi/"},{"title":"OC对象的本质","content":"简单了解NSObject的‘底层实现’、‘占用内存’及‘分类’。 NSObject的底层实现 oc中 @interface NSObject { Class isa; } @end 转为c++后 （64位系统中占8个字节，32位系统中占4个字节，以下均以64位系统为例） struct NSObject_IMPL { Class isa; // 占8个字节 }; Class实际上是一个指针 typedef struct objc_class *Class; 一个NSObject对象占多少内存？ 从上面的NSObject底层实现看，既然NSObject的对象本质上是一个isa的Class指针，而Class又占用8个字节，那么一个NSObject对象是不是就占用8个字节呢？实际上不是，一个NSObject实际上占用16个字节。alloc本质是在调用allocWithZone，其函数内部在分配内存时，会判断if( size &lt; 16 ){size = 16}， 总结：系统分配了16个字节给NSObject对象，但NSObject对象内部只使用了8个字节的空间(64bit环境下)。 NSObject *obj = [[NSObject alloc] init]; // 获得NSObject实例对象的 “成员变量” 所占用的大小（基于内存对齐原则，最大成员内存的倍数） NSLog(@&quot;%zd&quot;, class_getInstanceSize([NSObject class])); // 8 // 获得obj指针所指向的内存大小（16的倍数） NSLog(@&quot;%zd&quot;, malloc_size((__bridge const void *)obj)); // 16 OC对象的分类 instance对象（实例对象）NSObject *object = [[NSObject alloc] init]; class对象（类对象） 每个类在内存中有且只有一个class对象Class objectClass1 = [object class]; Class objectClass2 = object_getClass(object); // -(void)test; 方法是保存在类对象里的 meta-class对象（元类对象） 每个类在内存中有且只有一个meta-class对象 #import &lt;objc/runtime.h&gt; // 将类对象传入，获得元类对象（如果传入instance实例对象，则返回的是class对象） Class objectMetaClass = object_getClass(objectClass); // 元类对象 Class objectClass2 = object_getClass(object); // 类对象 // +(void)test; 类方法是保存在元类对象里的 object_getClass： Class object_getClass(id obj){ // 如果是instance对象，返回class对象； // 如果是class对象，返回meta-class对象 // 如果是meta-class对象，返回NSobject(基类)的meta-class对象； if (obj) return obj-&gt;getIsa(); else return Nil; } ","link":"https://daning.netlify.app/post/oc-dui-xiang-de-ben-zhi/"},{"title":"HTTP相关知识点","content":"HTTP、HTTPS等相关知识点整理 前言：什么是 HTTP？ 优点 HTTP 最凸出的优点是「简单、灵活和易于扩展、应⽤⼴泛和跨平台」。 简单 HTTP 基本的报⽂格式就是 header + body ，头部信息也是 key-value 简单⽂本的形式，易于理解， 降低了学习和使⽤的⻔槛。 灵活和易于扩展 HTTP协议⾥的各类请求⽅法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发⼈员⾃定义和扩充。同时 HTTP 由于是⼯作在应⽤层（ OSI 第七层），则它下层可以随意变化。HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚⾄把 TCP 层换成了基于 UDP 的 QUIC。 应⽤⼴泛和跨平台 互联⽹发展⾄今，HTTP 的应⽤范围⾮常的⼴泛，从台式机的浏览器到⼿机上的各种 APP，从看新闻、 刷贴吧到购物、理财、吃鸡，HTTP 的应⽤⽚地开花，同时天然具有跨平台的优越性。 缺点 HTTP 协议⾥有优缺点⼀体的双刃剑，分别是「⽆状态、明⽂传输」，同时还有⼀⼤缺点「不安全」。 性能如何？ ⻓连接 早期 HTTP/1.0 性能上的⼀个很⼤的问题，那就是每发起⼀个请求，都要新建⼀次 TCP 连接（三次握⼿），⽽且是串⾏请求，做了⽆谓的 TCP 连接建⽴和断开，增加了通信开销。 为了解决上述 TCP 连接问题，HTTP/1.1 提出了⻓连接的通信⽅式，也叫持久连接。这种⽅式的好处在于减少了 TCP 连接的 复建⽴和断开所造成的额外开销，减轻了服务器端的负载。 持久连接的特点是，只要任意⼀端没有明确提出断开连接，则保持 TCP 连接状态。 管道⽹络传输 HTTP/1.1 采⽤了⻓连接的⽅式，这使得管道（pipeline）⽹络传输成为了可能。 即可在同⼀个 TCP 连接⾥⾯，客户端可以发起多个请求，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以减少整体的响应时间。 队头阻塞 「请求 - 应答」的模式加剧了 HTTP 的性能问题。 因为当顺序发送的请求序列中的⼀个请求因为某种原因被阻塞时，在后⾯排队的所有请求也⼀同被阻塞了，会招致客户端⼀直请求不到数据，这也就是「队头阻塞」。 1. HTTP 与 HTTPS 的区别 HTTP 是超⽂本传输协议，信息是明⽂传输，存在安全⻛险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS 安全协议，使得报⽂能够加密传输。 HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ HTTPS 在 TCP 三 次握⼿之后，还需进⾏ SSL/TLS 的握⼿过程，才可进⼊加密报⽂传输。 HTTP 的端⼝号是 80，HTTPS 的端⼝号是 443。 HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。 2. HTTP/1.1、HTTP/2、HTTP/3 演变 HTTP/1.1 相⽐ HTTP/1.0 性能上的改进： 使⽤ TCP ⻓连接的⽅式改善了 HTTP/1.0 短连接造成的性能开销。 ⽀持管道（pipeline）⽹络传输，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以减少整体的响应时间 性能瓶颈： 请求 / 响应头部（Header）未经压缩就发送，⾸部信息越多延迟越⼤。只能压缩 Body 的部分； 发送冗⻓的⾸部。每次互相发送相同的⾸部造成的浪费较多； 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端⼀直请求不到数据，也就是队头阻塞； 没有请求优先级控制； 请求只能从客户端开始，服务器只能被动响应。 HTTP/2 HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。 相⽐ HTTP/1.1 性能上的改进： 头部压缩：HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是⼀样的或是相似的，那么，协议会帮你消除重复的部分。（这就是所谓的 HPACK 算法） ⼆进制格式：HTTP/2 不再像 HTTP/1.1 ⾥的纯⽂本形式的报⽂，⽽是全⾯采⽤了⼆进制格式，头信息和数据体都是⼆进制，并且统称为帧（frame）：头信息帧和数据帧。增加了数据传输的效率。 数据流：HTTP/2 的数据包不是按顺序发送的，同⼀个连接⾥⾯连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。每个请求或回应的所有数据包，称为⼀个数据流（ Stream ）。每个数据流都标记着⼀个独⼀⽆⼆的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数。客户端还可以指定数据流的优先级。优先级⾼的请求，服务器就先响应该请求。 多路复⽤：HTTP/2 是可以在⼀个连接中并发多个请求或回应，⽽不⽤按照顺序⼀⼀对应。移除了 HTTP/1.1 中的串⾏请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，⼤幅度提⾼了连接的利⽤率。 服务器推送：HTTP/2 还在⼀定程度上改善了传统的「请求 - 应答」⼯作模式，服务不再是被动地响应，也可以主动向客户端发送消息。例如浏览器刚请求 HTML 的时候，就提前把可能会⽤到的 JS、CSS ⽂件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。 缺陷 HTTP/2 主要的问题在于，多个 HTTP 请求在复⽤⼀个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。所以⼀旦发⽣了丢包现象，就会触发 TCP 的重传机制，这样在⼀个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来 HTTP/3 HTTP/1.1 中的管道（ pipeline）传输中如果有⼀个请求阻塞了，那么队列后请求也统统被阻塞住了 HTTP/2 多个请求复⽤⼀个TCP连接，⼀旦发⽣丢包，就会阻塞住所有的 HTTP 请求。 这都是基于 TCP 传输层的问题，所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！ 3. TCP 和 UDP 区别 连接 TCP 是面向连接的传输协议，传输数据前先要建立连接 UDP 不需要连接，即刻传输数据 服务对象 TCP 是一对一的两点服务，即一条连接只有两个端点 UDP 支持一对一，一对多，多对多的交互通信 可靠性 TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达 UDP 是尽最大努力交付，不保证可靠交付数据 拥塞控制、流量控制 TCP 有拥塞控制和流量控制机制，保证数据传输的安全性 UDP 则没有，即使网络非常拥堵，也不会影响 UDP 的发送速率 首部开销 TCP 首部长度较长，会有一定的开销，首部在没有使用【选项】字段时是 20 个字节，如果使用了【选项】字段则会变长的 UDO 首部只有 8 个字节，并且是固定不变的，开销较小 传输方式 TCP 是流式传输，没有边界，但保证顺序和可靠 UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序 分片不同 TCP 的数据大小如果大于 MSS 大小，则会在 传输层 进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。 UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层，但是如果中途丢了一个分片，则就需要重传所有的数据包，这样传输效率非常差，所以通常 UDP 的报文应小于 MTU。 TCP 和 UDP 的应用场景： 由于 TCP 是面向连接的，能保证数据的可靠交付，因此经常用于： 1. FTP 文件传输 2. HTTP / HTTPS 由于 UDP 是面向无连接的，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于： 1. 包总量较少的通信，如 DNS、SNMP 等 2. 视频、音频等多媒体通信 3. 广播通信 3. TCP 3次握手 ⼀开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端⼝，处于 LISTEN 状态。 然后客户端主动发起连接 SYN ，之后处于 SYN-SENT 状态。 服务端收到发起的连接，返回 SYN ，并且 ACK 客户端的 SYN ，之后处于 SYN-RCVD 状态。 客户端收到服务端发送的 SYN 和 ACK 之后，发送 ACK 的 ACK ，之后处于 ESTABLISHED 状态，因为它⼀发⼀收成功了。 服务端收到 ACK 的 ACK 之后，处于 ESTABLISHED 状态，因为它也⼀发⼀收了。 3.1 为什么是三次握⼿？不是两次、四次？ 可以阻⽌重复历史连接的初始化（主要原因） 客户端连续发送多次 SYN 建⽴连接的报⽂，在⽹络拥堵情况下： ⼀个「旧 SYN 报⽂」⽐「最新的 SYN 」 报⽂早到达了服务端； 那么此时服务端就会回⼀个 SYN + ACK 报⽂给客户端； 客户端收到后可以根据⾃身的上下⽂，判断这是⼀个历史连接（序列号过期或超时），那么客户端 就会发送 RST 报⽂给服务端，表示中⽌这⼀次连接。 如果是两次握⼿连接，就不能判断当前连接是否是历史连接，三次握⼿则可以在客户端（发送⽅）准备 发送第三次报⽂时，客户端因有⾜够的上下⽂来判断当前连接是否是历史连接： 如果是历史连接（序列号过期或超时），则第三次握⼿发送的报⽂是 RST 报⽂，以此中⽌历史连接； 如果不是历史连接，则第三次发送的报⽂是 ACK 报⽂，通信双⽅就会成功建⽴连接； 所以，TCP 使⽤三次握⼿建⽴连接的最主要原因是防⽌历史连接初始化了连接。 可以同步双⽅的初始序列号 TCP 协议的通信双⽅， 都必须维护⼀个「序列号」， 序列号是可靠传输的⼀个关键因素，它的作⽤： 接收⽅可以去除 复的数据； 接收⽅可以根据数据包的序列号按序接收； 可以标识发送出去的数据包中， 哪些是已经被对⽅收到的； 可以避免资源浪费 如果只有「两次握⼿」，当客户端的 SYN 请求连接在⽹络中阻塞，客户端没有接收到 ACK 报⽂，就会重新发送 SYN ，由于没有第三次握⼿，服务器不清楚客户端是否收到了⾃⼰发送的建⽴连接的ACK 确认信号，所以每收到⼀个 SYN 就只能先主动建⽴⼀个连接，这会造成什么情况呢？ 如果客户端的 SYN 阻塞了， 复发送多次 SYN 报⽂，那么服务器在收到请求后就会建⽴多个冗余的⽆效链接，造成不必要的资源浪费。 总结： TCP 建⽴连接时，通过三次握⼿能防⽌历史连接的建⽴，能减少双⽅不必要的资源开销，能帮助双⽅同步初始化序列号。序列号能够保证数据包不重复、不丢弃和按序传输。 不使⽤「两次握⼿」和「四次握⼿」的原因： [两次握⼿]：⽆法防⽌历史连接的建⽴，会造成双⽅资源的浪费，也⽆法可靠的同步双⽅序列号； [四次握⼿]：三次握⼿就已经理论上最少可靠连接建⽴，所以不需要使⽤更多的通信次数。 4. TCP 4次挥手 客户端打算关闭连接，此时会发送⼀个 TCP ⾸部 FIN 标志位被置为 1 的报⽂，也即 FIN 报⽂，之后客户端进⼊ FIN_WAIT_1 状态。 服务端收到该报⽂后，就向客户端发送 ACK 应答报⽂，接着服务端进⼊ CLOSED_WAIT 状态。 客户端收到服务端的 ACK 应答报⽂后，之后进⼊ FIN_WAIT_2 状态。 等待服务端处理完数据后，也向客户端发送 FIN 报⽂，之后服务端进⼊ LAST_ACK 状态。 客户端收到服务端的 FIN 报⽂后，回⼀个 ACK 应答报⽂，之后进⼊ TIME_WAIT 状态 服务器收到了 ACK 应答报⽂后，就进⼊了 CLOSED 状态，⾄此服务端已经完成连接的关闭。 客户端在经过 2MSL ⼀段时间后，⾃动进⼊ CLOSED 状态，⾄此客户端也完成连接的关闭。 可以看到，每个⽅向都需要⼀个 FIN 和⼀个 ACK，因此通常被称为四次挥⼿。 4.1 为什么四次挥手？TIME_WAIT == 2MSL？ 为什么4次挥手 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。 服务器收到客户端的 FIN 报⽂时，先回⼀个 ACK 应答报⽂，⽽服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报⽂给客户端来表示同意现在关闭连接。 从上⾯过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN ⼀般都会分开发送，从⽽⽐三次握⼿导致多了⼀次。 为什么 TIME_WAIT 等待的时间是 2MSL？ TIME_WAIT 等待 2 倍的 MSL，⽐较合理的解释是： ⽹络中可能存在来⾃发送⽅的数据包，当这些发送⽅的数据包被接收⽅处理后⼜会向对⽅发送响应，所以⼀来⼀回需要等待 2 倍的时间。在 Linux 系统⾥ 2MS 默认是 60 秒，那么⼀个 MSL 也就是 30 秒。Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒。 5. 键入网址后都发生了什么？ 解析 URL，生成 HTTP 的请求信息 真实地址查询 -- DNS （ 【本地 - 根 - 顶级域 - 权威】 DNS服务器 ） 协议栈 通过 DNS 获取到 IP 后，就可以把 HTTP 的传输⼯作交给操作系统中的协议栈。 3.1 可靠传输：TCP 协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，它们两会接受应⽤层的委托执⾏收发数据的操作。 3.2 远程定位：IP 协议栈的下⾯⼀半是⽤ IP 协议控制⽹络包收发操作，在互联⽹上传数据时，数据会被切分成⼀块块的⽹络包，⽽将⽹络包发送给对⽅的操作就是由 IP 负责的。此外 IP 中还包括 ICMP（error信息） 协议和 ARP（IP - MAC 映射） 协议。 3.3 两点传输：MAC ⽣成了 IP 头部之后，接下来⽹络包还需要在 IP 头部的前⾯加上 MAC 头部。MAC 头部是以太⽹使⽤的头部，它包含了接收⽅和发送⽅的 MAC 地址等信息。 出口 - 网卡 我们需要将数字信息转换为电信号，才能在⽹线上传输，负责执⾏这⼀操作的是⽹卡，要控制⽹卡还需要靠⽹卡驱动程序。 送别者 - 交换机 交换机的设计是将⽹络包原样转发到⽬的地。交换机⼯作在MAC 层，也称为⼆层⽹络设备。 出境⼤⻔ - 路由器 ⽹络包经过交换机之后，现在到达了路由器，并在此被转发到下⼀个路由器或⽬标设备。 互相扒⽪ - 服务器 与 客户端 数据包抵达服务器后，服务器开逐层解包 6. POST / GET 区别 Get ⽅法的含义是请求从服务器获取资源; ⽽ POST ⽅法则是相反操作，它向 URI 指定的资源提交数据，数据就放在报⽂的 body ⾥。 GET: 是安全且幂等的，因为它是「只读」操作，⽆论操作多少次，服务器上的数据 都是安全的，且每次的结果都是相同的。POST: 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。 7. 常见的状态码 8. 常用字段 Host 客户端发送请求时，⽤来指定服务器的域名。【www.A.com】有了 Host 字段，就可以将请求发往「同⼀台」服务器上的不同⽹站。 Content-Length 服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据⻓度。【Content-Length: 1000】 Connection Connection 字段最常⽤于客户端要求服务器使⽤ TCP 持久连接，以便其他请求复⽤。【Connection: keep-alive】 Content-Type Content-Type： ⽤于服务器回应时，告诉客户端，本次数据是什么格式。【Content-Type: text/html; charset=utf-8】 Accept: 客户端请求的时候，可以使⽤ Accept 字段声明⾃⼰可以接受哪些数据格式。【Accept: ※/※】 Content-Encoding Content-Encoding： 说明数据的压缩⽅法。表示服务器返回的数据使⽤了什么压缩格式 。【Content-Encoding: gzip】 Accept-Encoding：客户端在请求时，⽤ Accept-Encoding 字段说明⾃⼰可以接受哪些压缩⽅法。【Accept-Encoding: gzip, deflate】 ","link":"https://daning.netlify.app/post/http-xiang-guan-zhi-shi-dian/"},{"title":"HTTP相关协议、概念","content":"简单介绍下HTTP的相关协议、概念（TCP/IP、DNS、URI/URL、HTTPS、CDN、代理、状态码） TCP/IP TCP/IP 协议实际上是一系列网络通信协议的统称，其中最核心的两个协议是 TCP 和 IP，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。 IP 协议 IP 协议是“Internet Protocol”的缩写，主要目的是解决寻址和路由问题，以及如何在两点间传送数据包。IP 协议使用“IP 地址”的概念来定位互联网上的每一台计算机。 现在我们使用的 IP 协议大多数是 v4 版，地址是四个用“.”分隔的数字，例如“192.168.0.1”，总共有 2^32，大约 42 亿个可以分配的地址。看上去好像很多，但互联网的快速发展让地址的分配管理很快就“捉襟见肘”。所以，就又出现了 v6 版，使用 8 组“:”分隔的数字作为地址，容量扩大了很多，有 2^128 个，在未来的几十年里应该是足够用了。 TCP 协议 TCP 协议是“Transmission Control Protocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础。 “可靠”是指保证数据不丢失，“字节流”是指保证数据完整，所以在 TCP 协议的两端可以如同操作文件一样访问传输的数据，就像是读写在一个密闭的管道里“流动”的字节。 DNS 在 TCP/IP 协议中使用 IP 地址来标识计算机，数字形式的地址对于计算机来说是方便了，但对于人类来说却既难以记忆又难以输入。于是“域名系统”（Domain Name System）出现了，用有意义的名字来作为 IP 地址的等价替代. 在 DNS 中，“域名”（Domain Name）又称为“主机名”（Host），为了更好地标记不同国家或组织的主机，让名字更好记，所以被设计成了一个有层次的结构。 域名用“.”分隔成多个单词，级别从左到右逐级升高，最右边的被称为“顶级域名”。对于顶级域名，可能你随口就能说出几个，例如表示商业公司的“com”、表示教育机构的“edu”，表示国家的“cn”“uk”等。 但想要使用 TCP/IP 协议来通信仍然要使用 IP 地址，所以需要把域名做一个转换，“映射”到它的真实 IP，这就是所谓的“域名解析”。 HTTP 协议中并没有明确要求必须使用 DNS，但实际上为了方便访问互联网上的 Web 服务器，通常都会使用 DNS 来定位或标记主机名，间接地把 DNS 与 HTTP 绑在了一起。 URI/URL 有了 TCP/IP 和 DNS，是不足以任意访问网络上的资源的。DNS 和 IP 地址只是标记了互联网上的主机，无法访问主机上具体的资源内容。 所以就出现了 URI（Uniform Resource Identifier），中文名称是 统一资源标识符，使用它就能够唯一地标记互联网上资源。 URI 另一个更常用的表现形式是 URL（Uniform Resource Locator）， 统一资源定位符，也就是我们俗称的“网址”，它实际上是 URI 的一个子集，不过因为这两者几乎是相同的，差异不大，所以通常不会做严格的区分。 拿 Nginx 网站来举例 http://nginx.org/en/download.html 可以看到，URI 主要有三个基本的部分构成： 协议名：即访问该资源应当使用的协议，在这里是“http”； 主机名：即互联网上主机的标记，可以是域名或 IP 地址，在这里是“nginx.org”； 路径：即资源在主机上的位置，使用“/”分隔多级目录，在这里是“/en/download.html”。 HTTPS 在 TCP/IP、DNS 和 URI 的“加持”之下，HTTP 协议终于可以自由地访问任意的网页了，但是它并不安全，于是HTTPS出现了。 HTTPS 的全称是“HTTP over SSL/TLS”，也就是运行在 SSL/TLS 协议上的 HTTP。这里是 SSL/TLS，而不是 TCP/IP，它是一个负责加密通信的安全协议，建立在 TCP/IP 之上，所以也是个可靠的传输协议，可以被用作 HTTP 的下层。 HTTPS 实际上相当于“HTTP + SSL/TLS + TCP/IP” SSL/TLS SSL 的全称是“Secure Socket Layer”，由网景公司发明，当发展到 3.0 时被标准化，改名为 TLS，即“Transport Layer Security”，但由于历史的原因还是有很多人称之为 SSL/TLS，或者直接简称为 SSL。 SSL 使用了许多密码学最先进的研究成果，综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套上一副坚固的盔甲。 CDN 浏览器和服务器是 HTTP 协议的两个端点，在它们两个中间有个重要的角色就是 CDN CDN，全称是“Content Delivery Network”，翻译过来就是“内容分发网络”。它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。 CDN 有什么好处呢？简单来说，它可以缓存源站的数据，让浏览器的请求不用“千里迢迢”地到达源站服务器，直接在“半路”就可以获取响应。如果 CDN 的调度算法很优秀，更可以找到离用户最近的节点，大幅度缩短响应时间。 CDN 也是现在互联网中的一项重要基础设施，除了基本的网络加速外，还提供负载均衡、安全防护、边缘计算、跨运营商网络等功能，能够成倍地“放大”源站服务器的服务能力，很多云服务商都把 CDN 作为产品的一部分。 代理 代理（Proxy）是 HTTP 协议中请求方和应答方中间的一个环节，作为“中转站”，既可以转发客户端的请求，也可以转发服务器的应答。代理有很多的种类，常见的有： 匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器； 透明代理：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端； 正向代理：靠近客户端，代表客户端向服务器发送请求； 反向代理：靠近服务器端，代表服务器响应客户端的请求； CDN，实际上就是一种代理，它代替源站服务器响应客户端的请求，通常扮演着透明代理和反向代理的角色。 由于代理在传输过程中插入了一个“中间层”，所以可以在这个环节做很多有意思的事情，比如： 负载均衡：把访问请求均匀分散到多台机器，实现访问集群化； 内容缓存：暂存上下行的数据，减轻后端的压力； 安全防护：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器； 数据处理：提供压缩、加密等额外的功能。 状态码 RFC 标准把状态码分成了五类，用数字的第一位表示分类，而 0~99 不用，这样状态码的实际可用范围就大大缩小了，由 000~999 变成了 100~599。 这五类的具体含义是： 1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作； 2××：成功，报文已经收到并被正确处理； 3××：重定向，资源位置发生变动，需要客户端重新发送请求； 4××：客户端错误，请求报文有误，服务器无法处理； 5××：服务器错误，服务器在处理请求时内部发生了错误； ","link":"https://daning.netlify.app/post/http-xiang-guan-xie-yi/"},{"title":"HTTP协议中的\"四层\"与\"七层\"","content":"谈到HTTP协议，经常会遇到有关四层与七层的相关话题，那么他们之间的区别到底是什么呢？ 其实我们常说的四层与七层分层，对应的分别是： 四层：TCP/IP 网络分层模型 七层：OSI 网络分层模型 TCP/IP 网络分层模型 TCP/IP协议是目前网络上的通讯标准，它的设计者非常聪明，创造性的提出了&quot;分层&quot;的概念，把复杂的网络通信划分出了多个层次，再给每一个层次分配不同的职责，层次内只专心做自己的事情就好，下面是TCP/IP的协议栈的层次图： TCP/IP协议总共有四层，&quot;从下往上&quot;，分别是： 第一层：&quot;链接层&quot;（link layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。 第二层：&quot;网际层/网络互连层&quot;（internet layer），IP 协议就在这一层。因为 IP 协议定义了&quot; IP 地址&quot;的概念，所以就可以在&quot;链接层&quot;的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再&quot;翻译&quot;成 MAC 地址就可以了。 第三层：&quot;传输层&quot;（transport layer），这个层次协议的职责是保证数据在 IP 地址标记的两点之间&quot;可靠&quot;的传输，是 TCP 协议工作的层次，另外还有它的一个&quot;小伙伴&quot; UDP。 TCP 是一个有状态的协议，需要先与对方建立连接，然后才能发送数据，而且保证数据不丢失不重复。而 UDP 则比较简单，它无状态，不用事先建立连接就可以任意发送数据，但不保证数据一定会发到对方、两个协议的另一个重要的区别在于数据的形式。TCP 的数据是连续的&quot;字节流&quot;，有先后顺序，而 UDP 则是分散的小数据包，是顺序发，乱序收。 第四层：&quot;应用层&quot;（application layer），由于上三层把基础打的非常好，所以这一层就“百花齐放”了，有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP 等等，当然还有我们的HTTP。 MAC 层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。 OSI 网络分层模型 OSI：全称“开放式系统互联通讯参考模型”（Open System Interconnection Reference Model）。TCP/IP 发明于 1970 年代，当时除了它还有很多其他的网络协议，整个网络世界很混乱，这时候国际标准组织（ISO）注意到了这种现象，为了“统一”，于是设计出了新的网络分层模型，想用这个新框架统一各种网络协议。 OSI 模型分七层，部分层次和 TCP/IP 很像，从下到上分别是： 第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等； 第二层：数据链路层，相当于 TCP/IP 的链接层； 第三层：网络层，相当于 TCP/IP 的网际层； 第四层：传输层，相当于 TCP/IP 的传输层； 第五层：会话层，维护网络中的连接状态，即保持会话和同步； 第六层：表示层，把数据转换为合适、可理解的语法和语义； 第七层：应用层，面向具体的应用传输数据； OSI 分层模型在发布的时候就明确的表明是一个“参考”，不是强制标准。TCP/IP 是一个纯软件的栈，没有网络应有的最根基的电缆、网卡等物理设备的位置，而 OSI 则补足了这个缺失，在理论层面上描述网络更加完整。 两个分层模型的映射关系 第一层：物理层，TCP/IP 里无对应; 第二层：数据链路层，对应 TCP/IP 的链接层； 第三层：网络层，对应 TCP/IP 的网际层； 第四层：传输层，对应 TCP/IP 的传输层； 第五、六、七层：统一对应到 TCP/IP 的应用层。 所以你看，这就是“理想与现实”之间的矛盾。理想很美好，有七层，但现实很残酷，只有四层，“多余”的五层、六层就这样“消失”了。 但这也有一定的实际原因，OSI 的分层模型在四层以上分的太细，而 TCP/IP 实际应用时的会话管理、编码转换、压缩等和具体应用经常联系的很紧密，很难分开。例如，HTTP 协议就同时包含了连接管理和数据格式定义。 TCP/IP 协议栈的工作方式 发：HTTP 协议的传输过程就是这样通过协议栈逐层向下，每一层都添加本层的专有数据，层层打包，然后通过下层发送出去。 收：接收数据则是相反的操作，从下往上穿过协议栈，逐层拆包，每层去掉本层的专有头，上层就会拿到自己的数据。 说明：下层的传输过程对于上层是完全“透明”的，上层也不需要关心下层的具体实现细节，所以就 HTTP 层次来看，它不管下层是不是 TCP/IP 协议，看到的只是一个可靠的传输链路，只要把数据加上自己的头，对方就能原样收到。 补充 二层转发：设备工作在链路层，帧在经过交换机设备时，检查帧的头部信息，拿到目标mac地址，进行本地转发和广播。 三层路由：设备工作在ip层，报文经过有路由功能的设备时，设备分析报文中的头部信息，拿到ip地址，根据网段范围，进行本地转发或选择下一个网关。 DNS 协议工作在应用层，因为网络请求的第一步是域名解析。 CDN工作在应用层，因为CDN是“内容分发网络”，要看到内容就必须在应用层。 ","link":"https://daning.netlify.app/post/http-xie-yi-zhong-de-si-ceng-yu-qi-ceng/"},{"title":"正则相关","content":"对正则了解不多，在此记录一下平时经常用到的表达式&amp;修饰符 1 匹配规则 参考文章：正则表达式 - 匹配规则 例：校验字符串中是否包含 ':', ';', '/', '', '%', '`' NSString *nameRegex = @&quot;^[^:;\\\\\\\\/%`]+$&quot;; NSPredicate *namePredicate = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,nameRegex]; return [namePredicate evaluateWithObject:name]; 1.1 基本匹配模式 $符号 表示结尾：例如bucket$，匹配‘in a bucket’，而不匹配‘buckets’ ^符号 有2个含义： &quot;开头&quot;，以^abc为例：匹配以abc开头的字符串 &quot;非&quot;或&quot;排除&quot;，以^[^abc]+$为例：从头到尾，不包含（排除）a、b、c的字符串 1.2 字符簇 简单说就是用来描述我们匹配模式的方法，书写方式为[.....][a-z] //匹配所有的小写字母 [A-Z] //匹配所有的大写字母 [a-zA-Z] //匹配所有的字母 [0-9] //匹配所有的数字 [0-9\\.\\-] //匹配所有的数字，句号和减号 [ \\f\\r\\t\\n] //匹配所有的白字符 [^a-z] //除了小写字母以外的所有字符 [^\\\\\\/\\^] //除了(\\)(/)(^)之外的所有字符 [^\\&quot;\\'] //除了双引号(&quot;)和单引号(')之外的所有字符 举个栗子🌰，匹配一个小写字母和一个数字组成的字符串，如‘a1’、‘b2’，但不是&quot;ab2&quot;：^[a-z][0-9]$ 再举个栗子🌰，同样匹配2个字符的字符串，第一个不是数字，第二个是数字，如‘#1’、‘R2’：^[^0-9][0-9]$ 2 元字符 参考文章：正则表达式 - 元字符 这里组合演示了： ?&lt;= : xx之后 例：?&lt;=href 表示 匹配 href之后 (不包含href) ?= : xx之前 例： ?=href 表示 匹配 href之前 (包含href) .*? : 取尽量少的任意字符 注：.代表的是任意字符。* 代表的是取 0 至 无限长度。？代表的是非贪婪模式。 例子，CFBundleDisplayName=&quot;MUZO Player&quot;;字符串中，我想获取MUZO Player: (?&lt;=CFBundleDisplayName=&quot;).*?(?=&quot;) ?&lt;! : 不以xx开头 例子，遍历字符串文件时，想过滤掉 //&quot;adddevice_test&quot;=&quot;test&quot;;这种字串： // 不以(//)开头，并且格式为(&quot;xxx&quot;可能存在空格=可能存在空格&quot;xxx&quot;;) (?&lt;!//)&quot;.*?&quot; ?= ?”.*?”; ","link":"https://daning.netlify.app/post/regexp-rule/"},{"title":"使用 Gridea+Github Pages 搭建个人博客","content":"Gridea 是一个静态博客写作客户端，它对比Jekyll、Hexo搭建博客的优势就在于拥有一个独有的客户端，不需要把注意力放在UI的配置上，只需要进行简单的配置即可迅速上手搭建个人博客！ Github Pages简介 Github Pages官网 Github Pages是一个静态站点托管服务，也就是说你完全可以随便做一个静态网页，来展示你要的东西，最重要的一点，它是免费的！😏 Github Pages也有自己的主题，如果不依赖其他工具去搭建blog也是可以的，GitHub Pages 搭建教程，没尝试过，不做评价； Gridea 官网：Gridea官网 主题：Gridea主题 步骤 详细过程：官方教程 大体过程： 下载Gridea客户端 创建Github Token，路径：Setting -&gt; Developer settings -&gt; Personal access tokens -&gt; Generate new token; 创建完成后记得保存，如果退出当前页面，token就再也看不到了！ 创建仓库，并在客户端里配置Github信息； Netlify加速 如果需要使用Netlify的CDN加速，并免费自定义域名 可以参考：使用Netlify加速Github Pages访问速度(Jekyll) ","link":"https://daning.netlify.app/post/create-blog-with-gridea/"},{"title":"Mac监听键盘点击","content":"总结了Swift中，暂时发现的3种键盘(鼠标)点击的监听方式 注意，以下方法中，涉及到全局键盘监听的都需要系统提供权限才能正常使用，判断方式： //系统首选项&gt;安全&amp;隐私权&gt;隐私权&gt;辅助功能 - 请确保您的应用已被选中。 print(&quot;辅助功能:&quot;,AXIsProcessTrusted() ? &quot;信任&quot; : &quot;不信任&quot;) 一、系统自带的API 其实这两个监听就可以满足大部分的需求了，唯一的不足是像F7~F9的媒体功能键无法监听 Global监听 NSEvent.addGlobalMonitorForEvents(matching: [.keyDown]) { [unowned self] (event) in // flags貌似是获取与常规键无关的按键 let flags = event.modifierFlags.intersection(.deviceIndependentFlagsMask) // 常规 option || 带有左右键时的 cmd+option if (flags == NSEvent.ModifierFlags.option || flags.contains([.command,.option])) { self.playControlWithKeyCode(event.keyCode) } } Local监听 NSEvent.addLocalMonitorForEvents(matching: [.keyDown]) { [unowned self] (event) -&gt; NSEvent? in if self.TextFieldIsEditing == true { return event} let code = event.keyCode let flags = event.modifierFlags.intersection(.deviceIndependentFlagsMask) if (flags.contains([.option])) { // 包含option self.playControlWithKeyCode(code) } else { if flags == NSEvent.ModifierFlags.command { if code == kVK_ANSI_W { WindowManager.share.currentWindow?.close() } } else { if (code == kVK_ANSI_W || code == kVK_Space){ self.playControlWithKeyCode(code) } } } return nil } 二、子类化NSApplication 我们可以通过子类化NSApplication，拦截sendEvent来实现获取键盘鼠标的点击事件，就像注释中描述的，虽然可以达到获取媒体键的点击，但是却无法拦截唤起的iTunes，不过用来获取其他按钮的点击事件也是可以的 注意：子类化NSApplication，需更改Info.plist里的NSPrincipalClass，如果是Swift则设置为$(PRODUCT_MODULE_NAME).MyApplication才会有效，如果是OC则直接设置为MyApplication即可，当然类名可以自己随意定义，我这里仅仅举个例子 class MyApplication: NSApplication { // 可以通过重写sendEvent监听媒体功能键，但是会唤起iTunes音乐，无法拦截，所以放弃 override func sendEvent(_ event: NSEvent) { if event.type == .systemDefined &amp;&amp; event.subtype == .screenChanged { let keyCode : Int32 = (Int32((event.data1 &amp; 0xFFFF0000) &gt;&gt; 16)) let keyFlags = (event.data1 &amp; 0x0000FFFF) let keyState = ((keyFlags &amp; 0xFF00) &gt;&gt; 8) == 0xA mediaKeyEvent(withKeyCode: keyCode, andState: keyState) return } super.sendEvent(event) } } 三、CGEvent.tapCreate拦截 此方法一样可以直接获取键盘事件，比子类化NSApplication高级的是可以拦截事件，例如拦截媒体键对iTunes的控制，不废话，直接上代码 同时，有趣的是这种方式，在首次加载时，会弹出系统提示框，获取隐私服务权限，比较友好 // 这个方法也可以拿来监听键盘其他key的点击 func startListenCGEventTap() { func myCGEventCallback(proxy: CGEventTapProxy, type: CGEventType, event: CGEvent, refcon: UnsafeMutableRawPointer?) -&gt; Unmanaged&lt;CGEvent&gt;? { if(type == .tapDisabledByTimeout){ return Unmanaged.passRetained(event) } if let nsEvent = NSEvent.init(cgEvent: event) { if (nsEvent.type == .systemDefined &amp;&amp; nsEvent.subtype == .screenChanged ) { let keyCode : Int32 = (Int32((nsEvent.data1 &amp; 0xFFFF0000) &gt;&gt; 16)) let keyFlags = (nsEvent.data1 &amp; 0x0000FFFF) let keyState = ((keyFlags &amp; 0xFF00) &gt;&gt; 8) == 0xA // let keyIsRepeat = (keyFlags &amp; 0x1) &gt; 0 // if keyIsRepeat { // print(&quot;keyIsRepeat&quot;) // return nil // } mediaKeyEvent(withKeyCode: keyCode, andState: keyState) return nil } } return Unmanaged.passRetained(event) } // let eventMask = (1 &lt;&lt; CGEventType.keyDown.rawValue) | (1 &lt;&lt; CGEventType.keyUp.rawValue | (1 &lt;&lt; CGEventType.flagsChanged.rawValue)) // 创建eventTap，此时会唤起’打开隐私权限‘弹窗 if let eventTap = CGEvent.tapCreate(tap: .cgSessionEventTap, place: .headInsertEventTap, options: .defaultTap, eventsOfInterest: CGEventMask(NX_SYSDEFINEDMASK), callback: myCGEventCallback, userInfo: nil) { let runLoopSource = CFMachPortCreateRunLoopSource(kCFAllocatorSystemDefault, eventTap, 0) CFRunLoopAddSource(CFRunLoopGetCurrent(), runLoopSource, .commonModes) CGEvent.tapEnable(tap: eventTap, enable: true) CFRunLoopRun() } else { print(&quot;failed to create event tap&quot;) // exit(1) } } ","link":"https://daning.netlify.app/post/listen-keyboard-event/"},{"title":"NSMenu右键后，或者拖入文件时，cell的边框和下划线处理","content":"我们在配合使用 NSTableView/NSOutlineView 和 NSmenu 的时候，会发现右键cell时，会多出一个蓝色的边框; 拖入文件到tableview里时，cell上也会多出一个下划线; 这里介绍如何拦截并修改它们 一、右键cell时的边框 分析 右键cell后，边框的样子如下，很突兀: 实际上，就是在tableView上 addSubview 了一个 NSMenuHighlightView： 解决方式 暴力点，直接重写NSTableView的addSubview方法，拦截掉NSMenuHighlightView的添加: class DNTableView: NSTableView { // 禁止右键 cell 边框 override func addSubview(_ view: NSView) { if view.className != &quot;NSMenuHighlightView&quot; { super.addSubview(view) } } } 二、拖入文件时的下划线 当然也可以通过设置 tableView.draggingDestinationFeedbackStyle = .none 直接隐藏，但是我更想修改它的颜色 首先看看它的样子 其实原理和上面边框处理一样，也是通过重写addSubView进行拦截 // 禁止右键cell 边框 override func addSubview(_ view: NSView) { if view.className == &quot;NSMenuHighlightView&quot; { // 右键后cell上的线 return } else if view.className == &quot;NSDraggingDestinationView&quot; { // 拖动文件后，cell上的线 // 发现无法修改view的背景色，无奈只能覆盖一个color view，以后发现更好的修改方式再改 let newLineView = NSView() newLineView.frame = view.bounds newLineView.wantsLayer = true newLineView.layer?.backgroundColor = kRedHighlightColor.cgColor view.addSubview(newLineView) super.addSubview(view) } else { super.addSubview(view) } } 再来看看修改后的样子 ","link":"https://daning.netlify.app/post/table-view-menu-right-click/"},{"title":"自定义NSSlider","content":"见名知意，本文介绍如何自定义NSSlider NSSlider由2部分组成，外层的NSSlider以及内部的NSSliderCell。通常我们所说的自定义Slider说的就是自定义NSSliderCell。 自定义NSSliderCell 以我自定定义的DNSliderCell举例 1. 定义/实现代理 NSSliderCell继承自NSActionCell，NSActionCell继承自NSCell，有关Tracking的方法都在NSCell中， 所以我们完全可以通过重写Tracking的相关方法来自定义Slider的点击、拖拽... @objc protocol DNSliderCellDelegate { // 我这里定义的都是可选代理，代理者可根据需求去实现方法 // 开始拖动 @objc optional func startTracking(doubleValue:Double ,sender:DNSliderCell) // 正在拖动 @objc optional func continueTracking(doubleValue:Double ,sender:DNSliderCell) // 拖动结束 &amp; 点击结束 @objc optional func stopTracking(doubleValue:Double ,sender:DNSliderCell) } extension DNSliderCell { //MARK: 开始拖动 override func startTracking(at startPoint: NSPoint, in controlView: NSView) -&gt; Bool { delegate?.startTracking?(doubleValue: doubleValue, sender: self) return super.startTracking(at: startPoint, in: controlView) } //MARK: 拖动中 override func continueTracking(last lastPoint: NSPoint, current currentPoint: NSPoint, in controlView: NSView) -&gt; Bool { delegate?.continueTracking?(doubleValue: doubleValue, sender: self) return super.continueTracking(last: lastPoint, current: currentPoint, in: controlView) } //MARK: 结束拖动 &amp; 点击结束 override func stopTracking(last lastPoint: NSPoint, current stopPoint: NSPoint, in controlView: NSView, mouseIsUp flag: Bool) { delegate?.stopTracking?(doubleValue: doubleValue, sender: self) super.stopTracking(last: lastPoint, current: stopPoint, in: controlView, mouseIsUp: flag) } } 2. 定义属性 可以根据需求自己定义常量或者变量，需要注意的是，Swift5、macOS Catalina 10.15.4上，xib创建的NSSlider会向两边各延伸2个px（其他版本是否如此不确定），例如我自己定义长度1000的slider，实际上长度为1004，所以定义了个Offset方便计算。 class DNSliderCell: NSSliderCell { let Offset:CGFloat = 2 // 进度条，实际上向（根据slider方向）左/右 或者 上/下 偏移2 let progressColor = kRedHighlightColor // 进度条进度背景色 var backgroundColor = NSColor.clear // 进度条整体背景色 let knobColor = kRedHighlightColor // 按钮颜色 let sliderThickness:CGFloat = 3.0 // 进度条厚度 let sliderBarRadius:CGFloat = 0 // 进度条圆角 let KnobWidth:CGFloat = 12.0 // 按钮宽度 let KnobHeight:CGFloat = 12.0 // 按钮高度 var progressRect = NSRect() // 进度的Rect var needControlKnobHidden = false // 是否需要控制旋钮显示隐藏 weak var delegate:DNSliderCellDelegate? // 代理 // slider是否是竖直 lazy var isSliderVertical:Bool = { let isVertical = (controlView as? DNSlider)?.isVertical == true return isVertical }() } 3. 重绘slider 要根据其Slider是横着还是竖着的来计算不同的rect extension DNSliderCell { //MARK: - 重绘slider override func drawBar(inside rect: NSRect, flipped: Bool) { //MARK: 修改进度条'整体'背景色 // 1. 获取 slider 的 rect var sliderRect = rect // 2. 更改 slider 厚度 if isSliderVertical { sliderRect.size.width = sliderThickness } else { sliderRect.size.height = sliderThickness } // 3. 填充背景色 let background = NSBezierPath(roundedRect: sliderRect, xRadius: sliderBarRadius, yRadius: sliderBarRadius) self.backgroundColor.setFill() background.fill() //MARK: 修改进度条'进度'背景色 // 1. 计算当前进度的占有比例 let value:CGFloat = CGFloat((doubleValue - minValue) / (maxValue - minValue)) // 2. 根据比例计算进度应有的长度 var viewLength:CGFloat if isSliderVertical { viewLength = (controlView?.frame.size.height)! } else { viewLength = (controlView?.frame.size.width)! } let finalLength:CGFloat = value * (viewLength - Offset * 2) // 3. 计算进度的Rect progressRect = sliderRect if isSliderVertical { progressRect.size.height = finalLength progressRect.origin.y = Offset } else { progressRect.size.width = finalLength progressRect.origin.x = Offset } // 4. 填充进度背景色 let active = NSBezierPath(roundedRect: progressRect, xRadius: sliderBarRadius, yRadius: sliderBarRadius) self.progressColor.setFill() active.fill() } } 4. 重绘旋钮 要根据其Slider是横着还是竖着的来计算不同的rect //MARK: - 重绘旋钮 override func drawKnob() { // 根据比例计算进度应有的OriginX let value:CGFloat = CGFloat((doubleValue - minValue) / (maxValue - minValue)) var viewLength:CGFloat if isSliderVertical{ viewLength = (controlView?.frame.size.height)! } else { viewLength = (controlView?.frame.size.width)! } var customKnobRect:NSRect if isSliderVertical { // Offset + 进度 * (( 实际宽度 ) - knob宽度 ) let finalStart:CGFloat = Offset + value * (viewLength - Offset * 2 - KnobHeight) // 计算Knob的Rect customKnobRect = NSRect(x: progressRect.origin.x + progressRect.size.width / 2 - KnobWidth / 2, y: finalStart, width: KnobWidth , height: KnobHeight) } else { // Offset + 进度 * (( 实际宽度 ) - knob宽度 ) let finalStart:CGFloat = Offset + value * (viewLength - Offset * 2 - KnobWidth) // 计算Knob的Rect customKnobRect = NSRect(x: finalStart, y: progressRect.origin.y + progressRect.size.height / 2 - KnobHeight / 2, width: KnobWidth , height: KnobHeight) } // 填充Knob的颜色 let background = NSBezierPath(roundedRect: customKnobRect, xRadius: KnobWidth / 2, yRadius: KnobHeight / 2) if needControlKnobHidden == true { if (controlView as? DNSlider)?.shouKnob == true { self.knobColor.setFill() } else { NSColor.clear.setFill() } } else { self.knobColor.setFill() } background.fill() } 自定义NSSlider 自定义NSSlider，可以处理鼠标滑过时鼠标指针的状态、控制knob的显示隐藏等; 不废话直接上代码！ class DNSlider: NSSlider { private var trackingArea:NSTrackingArea? // 是否显示knob var shouKnob:Bool = false } extension DNSlider { override func updateTrackingAreas() { super.updateTrackingAreas() if trackingArea != nil { self.removeTrackingArea(trackingArea!) } // 将设置追踪区域为控件大小 // 设置鼠标追踪区域，如果不设置追踪区域，mouseEntered和mouseExited会无效 trackingArea = NSTrackingArea(rect: bounds, options: [.mouseEnteredAndExited, .activeAlways], owner: self, userInfo: nil) self.addTrackingArea(trackingArea!) } override func mouseEntered(with event: NSEvent) { super.mouseEntered(with: event) NSCursor.pointingHand.set() /* 通过设置 isHighlighted 取反来触发 cell 的 drawKnob 方法; 通过 shouKnob 来控制是否显示(因为isHighlighted受其他状态影响，无法精准控制) */ shouKnob = true isHighlighted = !isHighlighted } override func mouseExited(with event: NSEvent) { super.mouseExited(with: event) NSCursor.arrow.set() shouKnob = false // 不直接设置true/false是因为如果在mouseExited前isHighlighted已经是true/false，那就无法触发cell重新渲染了 isHighlighted = !isHighlighted } // 点击后，状态会刷新，此时如不做更改会默认改回指针状态 override func cursorUpdate(with event: NSEvent) { super.cursorUpdate(with: event) NSCursor.pointingHand.set() } } ","link":"https://daning.netlify.app/post/custom-nsslider/"},{"title":"MacOS关闭按钮与Reopen","content":"在点击Window上的Close按钮后，再在dock栏里重新选中软件，这时软件的各种状态都会重置，一些设置的unowned的地方甚至会crash，这相当于一个半成品的reopen；我们需要的是点击关闭按钮并不会杀掉软件，而是隐藏起来，点击后展示之前软件的显示状态； 步骤 实现方式很简单，一共就需要两步 //1. 首先定义mainWindow，并在加载后赋值 var mainWindow: NSWindow! func applicationDidFinishLaunching(_ aNotification: Notification) { mainWindow = NSApplication.shared.windows[0] } //2. 然后继承NSWindowDelegate，并实现如下方法 extension AppDelegate: NSWindowDelegate { func applicationShouldHandleReopen(_ sender: NSApplication, hasVisibleWindows flag: Bool) -&gt; Bool { if !flag { mainWindow.makeKeyAndOrderFront(nil) // 这里是核心代码 } return false // 这里要设为false，不然会reopen一个窗口 } } ","link":"https://daning.netlify.app/post/mac-close-and-reopen/"},{"title":"MacOS自定义TitleBar","content":"简单介绍MacOS开发中如何自定义TitleBar 默认样式 默认的样式如下，无论是可选中的范围还是样式都比较有局限性 目标示例样式 期待的样式如下，选中的范围变高，内容更自由和丰富 选中范围变大意味着什么？Mac上可以通过拖拽TitleBar来移动整个Window窗口，范围变大则操作更舒服 思路 NSWindow上的Titlebar可以被隐藏； NSView可以通过重写mouseDownCanMoveWindow来控制长按移动窗口 步骤 自定义CustomWindow，继承自NSWindow，然后在Storyboard中将Window的Class改为CustomWindow 重新initWithContentRect方法，并隐藏Titlebar，并设置内容铺满整个window（fullSizeContentView） class CustomWindow: NSWindow { // 个别属性可以在Storyboard里直接设置，这里都用代码写了 override init(contentRect: NSRect, styleMask style: NSWindow.StyleMask, backing backingStoreType: NSWindow.BackingStoreType, defer flag: Bool) { // styleMask 默认是 [.titled, .closable, .miniaturizable, .resizable] super.init(contentRect: contentRect, styleMask:[.titled, .closable, .miniaturizable, .resizable, .fullSizeContentView], backing: backingStoreType, defer: flag) // titlebar透明 titlebarAppearsTransparent = true // 隐藏title titleVisibility = NSWindow.TitleVisibility.hidden // 点击窗口背景支持鼠标拖动窗口 isMovableByWindowBackground = true // 设置透明背景 isOpaque = false backgroundColor = NSColor.clear } } 自定义一个NSView，设定好高度和位置代替原Titlebar 此时拖拽窗口的任何位置都可以移动window，那么就要把rootView的mouseDownCanMoveWindow重写为false，CustomTitleBae的mouseDownCanMoveWindow重写为true override var mouseDownCanMoveWindow: Bool { return true; // 该属性默认为true } 最后记得给rootView设置圆角，不然默认是没有圆角的(我这里直接Storyboard里设置了) wantsLayer = true layer.cornerRadius = 7.0 layer.masksToBounds = true 最终效果 ","link":"https://daning.netlify.app/post/macos-custom-titlebar/"},{"title":"获取APP图片资源(破解Assets.car)","content":"在借鉴(抄袭)或学习一个APP的时候，总是情不自禁的想直接使用人家的图片资源，在拿到iPA或者在MAC下的应用程序里，图片资源一般是Assets.car，这里我们介绍下如何打开这个文件 工具 cartool：Github地址 使用方式 很简单，download到本地后，按照以下步骤，即可直接运行程序获取图片资源: 找到 cartool -&gt; Edit Scheme -&gt; Run -&gt; Arguments 在 Ayguments Passed On Launch 配置如下参数： 第一个是Assets.car文件路径，第二个是图片文件输出的文件夹路径 运行程序，完成破解 运行报错 在macOS系统上，有时可能会报错 按照以下方式修改即可 添加初始化方法 -(id)initWithURL:(NSURL *)URL error:(NSError **)error; 修改代码 // CUIThemeFacet *facet = [CUIThemeFacet themeWithContentsOfURL:[NSURL fileURLWithPath:carPath] error:&amp;error]; // // CUICatalog *catalog = [[CUICatalog alloc] init]; // // /* Override CUICatalog to point to a file rather than a bundle */ // [catalog setValue:facet forKey:@&quot;_storageRef&quot;]; CUICatalog *catalog = nil; if ([CUICatalog instancesRespondToSelector:@selector(initWithURL:error:)]) { /* If CUICatalog has the URL API (Mojave), use it. */ catalog = [[CUICatalog alloc] initWithURL:[NSURL fileURLWithPath:carPath] error:&amp;error]; } else { CUIThemeFacet *facet = [CUIThemeFacet themeWithContentsOfURL:[NSURL fileURLWithPath:carPath] error:&amp;error]; catalog = [[CUICatalog alloc] init]; /* Override CUICatalog to point to a file rather than a bundle */ [catalog setValue:facet forKey:@&quot;_storageRef&quot;]; } NSCAssert(!error, @&quot;Error attempting to open asset catalog (%@): %@&quot;, carPath, error); ","link":"https://daning.netlify.app/post/get-assetscar/"},{"title":"Charles抓包工具介绍","content":"Charles(青花瓷)是HTTP的抓包工具，可以有效地获取HTTP通信信息；此文章使用的是Charles V4.5.6版本 首先展示一下Charles的页面 安装 安装教程可参考：链接 Charles下载： 原下载地址 百度云 密码:a999 安装步骤 按照上述安装包下载后，即可获取破解版的dmg文件 安装完成后打开Charles，在上方菜单栏的“Help”选择“Register Charles”，会弹出一个Charles for Mac注册界面。 打开解压文件夹中的“keygen.jar” 在运行后的“keygen.jar”上输入“orsoon”然后点击“Generate”生成Charles注册码 然后将生成的charles注册码复制到注册界面的对应位置上，再点击“Register”。 之后会提示注册完成，到这里就可以开始免费使用Charles了。 注意！：在第3步时，可能会提示您需要安装JDK才能使用“java”命令行工具，最简单的安装方式如下： brew cask install oracle-jdk 当然也可以去官网下载JDK 使用方式 在此介绍一下如何用Charles抓取手机上的https请求; 参考：链接 第一步：安装Charles证书到Mac 启动Charles，选择Help--&gt;SSL Proxying→Install Charles Root Certificate，此时会自动在钥匙串里安装证书 在钥匙串中找到证书Charles Proxy CA，然后双击或者右键显示简介，点开信任选项，选择始终信任 移动复制该证书到“系统”里面。此时电脑端的证书就配置完毕了！ 第二步：设置HTTPS端口抓包 点击Charles--&gt;Proxy--&gt;SSL Proxying Settings，点击&quot;Enable SSL Proxying&quot;,点击“Add” Host填通配符 * ，Port填通用端口 443 第三步：安装Charles证书到手机 首先查看电脑IP地址，点击Charles--&gt;Help→Local IP Address；也可以在网络偏好设置里看；也可以命令行 fconfig en0查看; 手机必须和电脑在同一个Wi-Fi下，然后到wifi详情里，选择配置代理 将代理模式改为手动，填入对应ip，端口号默认8888 此时会弹出提示，点击Allow 然后打开Safari浏览器，访问：chls.pro/ssl，下载证书 然后再设置--&gt;通用→描述文件，安装刚下载好的文件 安装完成后，点击 设置--&gt;通用→关于本机，下拉到底部，点击证书 信任设置，把刚信任开关打开。 大功告成，此时你就可以愉快的抓HTTPS的包了。 ","link":"https://daning.netlify.app/post/ho-to-use-charles/"},{"title":"GitBook常用插件","content":"整理一下目前发现的GitBook的插件（plugins），各插件具体使用方式请看其对应的官方介绍 1. 时序图 插件：js-sequence-diagram-full 说明：时序图样式插件 官方介绍 示例： &quot;plugins&quot;: [&quot;js-sequence-diagram-full@&gt;=0.3.1&quot;] 书写方式： （```sequence）// 忽略括号 participant A participant B Note over C: Note over C Note over A: Note over A C-&gt;D: C-&gt;D D-&gt;B: D-&gt;B B--&gt;D: B--&gt;D D--&gt;C: D--&gt;C A-&gt;A: A-&gt;A （```） 效果图： 2. 代码块 插件：prism 说明：代码块的样式插件 官方介绍 参数说明： css：代码块样式，官方说明上有几种不同的样式 lang：可以自定义重命名代码块命名，例如 objectivec 有点长，我们就重命名为 oc ignore：忽略其他可能会引起冲突的代码块插件的代码块名字，如 js-sequence-diagram-full 的 sequence 示例： &quot;plugins&quot;: [&quot;prism&quot;] &quot;pluginsConfig&quot;: { &quot;prism&quot;: { &quot;css&quot;: [&quot;prismjs/themes/prism-okaidia.css&quot;], &quot;lang&quot;: {&quot;oc&quot;: &quot;objectivec&quot;,}, &quot;ignore&quot;: [&quot;sequence&quot;] } } 效果图： 3. 锚点 插件：anchors 说明：标题带有 github 样式的锚点。(其实就是鼠标hover在对应h标签后，有个链接小图标显示，点击后标题稍微置顶) 如果使用了 anchor-navigation-ex，那就不需要这个anchors插件了，已被其包含 官方介绍 示例： &quot;plugins&quot; : [ &quot;anchors&quot; ] 效果图： 4. 目录宽度拖拽 插件：splitter 说明：在左侧目录和右侧内容之间添加一个可以拖拽的栏，用来调整两边的宽度。 官方介绍 示例： &quot;plugins&quot; : [ &quot;splitter&quot; ] 效果图： 5. gtalk 评论 插件：gtalk 说明：添加gitalk评论插件 官方介绍 &quot;plugins&quot;: [&quot;gtalk&quot;] &quot;pluginsConfig&quot;: { &quot;gtalk&quot;: { &quot;clientID&quot;: &quot;GitHub Application Client ID&quot;, &quot;clientSecret&quot;: &quot;GitHub Application Client Secret&quot;, &quot;repo&quot;: &quot;GitHub repo&quot;, &quot;owner&quot;: &quot;GitHub repo owner&quot;, &quot;admin&quot;: [&quot;GitHub repo owner and collaborators, only these guys can initialize github issues&quot;] } } 6. github 插件：github 说明：在右上角显示 github 仓库的图标链接。 官方介绍 示例： &quot;plugins&quot;: [ &quot;github&quot; ] &quot;pluginsConfig&quot;: { &quot;github&quot;: { &quot;url&quot;: &quot;https://github.com/your/repo&quot; } } 7. 章节目录 插件：anchor-navigation-ex 说明：目录插件 官方介绍 具体参数介绍 示例： &quot;plugins&quot;: [ &quot;anchor-navigation-ex&quot; ] &quot;pluginsConfig&quot;: { &quot;anchor-navigation-ex&quot;: { &quot;showGoTop&quot;:true, #右下角是否添加“返回顶部”按钮 &quot;showLevel&quot;: false, #标题是否显示层级序号（控制页面标题是否被重写） &quot;printLog&quot;: true, #是否打印处理日志,在排查生成book失败的时候很有用 &quot;mode&quot;: &quot;float&quot;, #目录的显示模式，目前有三种“float悬浮”、“pageTop文章顶部”、“”不显示，默认float &quot;float&quot;: { #对应floatMode的图标，可以设置目录里标题前面的ICON &quot;floatIcon&quot;: &quot;fa fa-navicon&quot;, &quot;showLevelIcon&quot;: true, &quot;level1Icon&quot;: &quot;fa fa-hand-o-right&quot;, &quot;level2Icon&quot;: &quot;fa fa-hand-o-right&quot;, &quot;level3Icon&quot;: &quot;fa fa-hand-o-right&quot; } } } 8. book目录折叠 插件：expandable-chapters-small 说明：左侧的主目录折叠插件 官方介绍 示例： &quot;plugins&quot;: [&quot;expandable-chapters-small&quot;] 效果图： 9. 访问数量 插件：pageview-count 说明：文档页面阅读数插件，菜单栏增加个小眼睛，显示访问次数 PS: 经查询，是访问 https://hitcounter.pythonanywhere.com/count/文章地址 来查询访问次数的 官方介绍 示例： &quot;plugins&quot;: [&quot;pageview-count&quot;] 效果图： 10. 多语言国际化 插件：language-picker 说明：语言切换插件 官方介绍 示例： &quot;plugins&quot;: [&quot;language-picker&quot;] &quot;pluginsConfig&quot;: { &quot;language-picker&quot;: { #可以不设置，默认两种 &quot;grid-columns&quot;: 2 #如果想设置更多种语言，就改这里即可 } } 使用细节，以中/英文2种语言为例: 使用此插件后，GitBook的目录结构需要同时调整，删除以前的SUMMARY 创建en、zh-hans2个文件夹，分别创建其对应的README.md和SUMMARY.md 根目录创建LANGS.md，指定中/英文文档入口，例如 * [English](en/) * [简体中文](zh-hans/) 这样该gitbook的初始页面其实就变成了LANGS.md，并同时提供了中/英文文档入口。例如： 11. 插入自定义css/js 插件：addcssjs 说明：给gitbook添加外部的css、js文件 官方介绍 示例： &quot;plugins&quot;: [&quot;addcssjs&quot;] &quot;pluginsConfig&quot;: { &quot;addcssjs&quot;: { &quot;css&quot;: [&quot;styles/website.css&quot;], &quot;js&quot;: [&quot;styles/website.js&quot;] } } 如果你使用了language-picker，那么在pluginsConfig配置路径时，记得要在路径前加上../;因为国际化后，所有book的html已经不在根目录的上了，而是在对应的语言文件夹下面 12. 代码块行号、复制 插件：code 说明：为代码块添加行号和复制按钮，复制按钮可关闭 官方介绍 { &quot;plugins&quot; : [ &quot;code&quot; ], &quot;pluginsConfig&quot;: { &quot;code&quot;: { &quot;copyButtons&quot;: false #复制按钮可关闭 } } } ","link":"https://daning.netlify.app/post/gitbook-plugins/"},{"title":"npm镜像管理","content":"npm install 或者 gitbook install的时候，经常遇见网速导致的卡慢问题，这里介绍 nrm 说明：此文 copy 自 -&gt; 简书 · 作者：四月天__ 此文列出常见npm命令，大家共勉。 查看npm源地址 npm config list 结果: metrics-registry = &quot;http://registry.npm.taobao.org/&quot; 修改registry地址，比如修改为淘宝镜像源。 npm set registry https://registry.npm.taobao.org/ 如果有一天你肉身FQ到国外，用不上了，用rm命令删掉它 npm config rm registry nrm是专门用来管理和快速切换私人配置的registry，建议全局安装 npm install nrm -g --save 用nrm ls命令查看默认配置，带*号即为当前使用的配置 nrm ls npm ---- https://registry.npmjs.org/ cnpm --- http://r.cnpmjs.org/ * taobao - https://registry.npm.taobao.org/ nj ----- https://registry.nodejitsu.com/ rednpm - http://registry.mirror.cqupt.edu.cn/ npmMirror https://skimdb.npmjs.com/registry/ edunpm - http://registry.enpmjs.org/ 也可以直接输入以下命令查看当前使用的是哪个源 nrm current 切换源 nrm use cnpm 用nrm add 命令添加公司私有npm源，如http://registry.npm.360.org(随便写的)，起个别名叫qihoo nrm add qihoo http://registry.npm.360.org 测试下速度 nrm test npm 输出npm ---- 790ms 最后，如果你被公司开除了，怒删公司npm源配置 nrm del qihoo 更新Node版本和npm版本 清除node的cache（清除node的缓存，这个看情况而定，不是必须的） sudo npm cache clean -f 安装&quot;n&quot;版本管理工具，管理node（没有错，就是n） sudo npm install -g n 更新node版本 sudo npm install npm@latest -g 再查一遍本机当前Node和npm的版本吧 node -v npm -v ","link":"https://daning.netlify.app/post/npm-management/"},{"title":"GitBook搭建及配置","content":"使用Jekyll去搭建SDK文档的网站虽然自由度高，但是想支持的非常好需要很娴熟的html技能； GitBook有固定好的框架，非常适合书写SDK文档。 1 GitBook简介 GitBook官网 GitBook文档 2 GitBook本地创建步骤 创建好指定目录后，在该目录下执行 gitbook init 首次init后，会自动生成README.md 和 SUMMARY.md 这两个文件；README就是说明文档，而SUMMARY其实就是页面的目录结构 这时候其实就已经完成了初创GitBook了，接下来输入 gitbook serve 命令，就可以直接拉起 http://localhost:4000 本地serve，在浏览器可以直接展示 接下来便可以针对此GibBook增加配置了，配置信息要放在 book.json里，例如： { &quot;title&quot;: &quot;LinkPlay SDK&quot;, #本书标题 &quot;author&quot;: &quot;LinkPlay&quot;, #本书作者 &quot;description&quot;: &quot;LinkPlay SDK 文档&quot;, #本书描述 &quot;language&quot;: &quot;zh-hans&quot;, #本书语言，中文设置 &quot;zh-hans&quot; 即可 &quot;styles&quot;: { &quot;website&quot;: &quot;./styles/website.css&quot; #自定义页面样式 }, &quot;structure&quot;: { &quot;readme&quot;: &quot;README.md&quot; #指定Readme、Summary、Glossary和Languages对应的文件名 }, &quot;plugins&quot;: [ #配置使用的插件 &quot;-sharing&quot;, #自带插件，前面加减号可以禁用 &quot;github&quot;, &quot;-livereload&quot; #热加载，自带插件，强烈建议删除，如果开放然后查看其代码，会发现其端口号为35729，和网站上常用的80端口号不同；本地用着很爽，但是网页加载很慢，浏览器Title会转很久 ], &quot;pluginsConfig&quot;: { #配置插件的属性 &quot;github&quot;: { &quot;url&quot;: &quot;https://github.com/linkplayapp/linkplay_sdk_doc&quot; }, } } 如果book.json配置中包含plugins，那么在重新 gitbook serve 前需要先 gitbook install ，安装对应的插件，实际上就是用npm去install 接下来就可以配置页面的目录结构，修改 SUMMARY.md ，便可达到修改目录的作用，例： # Summary * [介绍](README.md) * [iOS](iOS/README.md) &lt;!-- 如果把md中的文档在左侧显示目录，可以拼接(#标题名) --&gt; * [Device_SDK](iOS/Device_SDK.md#标题1) * [Device_SDK](iOS/Device_SDK.md#标题2) * [Android](android/README.md) * [测试](android/Test.md) 3 Github上配套搭建环境 先创建个仓库，然后clone至本地，并将上面步骤生成的代码全部copy到该目录下 最好还是gitignore掉node_modules文件夹，然后将代码push到master上;(记得把_book文件夹备份一下，接下来会用到) 然后创建gh-pages分支，命名最好如此，默认的规则，不然以后Gitbook链接会受到不定影响git checkout -b gh-pages 在gh-pages分支下，先清空文件夹，将第2步准备好的_book里的所有内容copy到当前目录下（注意是copy _book文件下的所有子项，而不是仅仅把文件夹拷贝） 此时可以提交了 访问自己这个库的github地址，然后到setting里面 找到options下面的github pages下的二级域名，这就是此gitbook的地址 4 FAQ 1 为什么要创建gh-pages分支？ gitbook serve时，本地会生成_book文件夹，里面就是网站的静态资源文件，其中index.html就是网站的入口； github pages的原理是加载html的静态资源文件，所以只要让github pages加载_book这个文件夹就可以实现gitbook网站的展示； 但是由于_book里的静态资源是在_book的文件夹里的，所以要新建一个分支，间接删掉_book这一层，直接将其下的资源文件放在分支里。 因此我们创建了gh-pages分支，并且把master下_book的内容全部copy到该分支下，这样就可以实现网站展示了； 2 为什么Gitbook展示的是gh-pages分支，而不是master分支？ 我猜是由于github有自动检测的机制，发现master分支下没有index.html，但是gp-pages分支根目录下却有index.html，所以默认gh-pages为github pages 访问的分支。当然也可以自己手动更改： 3 有没有好的方法避免每次手动copy _book下文件 第一种： 可以用jenkins：由master去监控master分支，轮询或者监听方式具体不了解，以此来实现每次master有变化，就去自动切换到gh-pages分支，copy master分支的_book资源文件 第二种： 写了个脚本，将步骤缩减至2步； 切换至gh-pages 执行脚本 脚本具体步骤： git fetch 、 git rebase 保证gh-pages分支为最新 git checkout master -- _book 把master下_book拉到当前分支下 递归遍历_book，把子文件全部覆盖至当前目录 删除_book git add . git commit -m 'Update by 当前时间' git push origin gh-pages 提交代码 git checkout master 切换回master分支 例： import os import shutil import datetime print(&quot;*** gf &amp;&amp; gr&quot;) os.system(&quot;git fetch&quot;) os.system(&quot;git rebase&quot;) print(&quot;*** Copy from master's _book ***&quot;) os.system(&quot;git checkout master -- _book&quot;) target_path = os.getcwd() book_path = os.path.join(target_path, &quot;_book&quot;) if(os.path.exists(book_path)): print(&quot;*** Start copy ***&quot;) for a in os.walk(book_path): # 递归创建目录 for d in a[1]: dir_path = os.path.join(a[0].replace(book_path, target_path), d) if not os.path.isdir(dir_path): # 不存在就创建 os.makedirs(dir_path) # 递归拷贝文件 for f in a[2]: dep_path = os.path.join(a[0], f) # _book 目录下的每个文件的绝对路径 arr_path = os.path.join(a[0].replace( book_path, target_path), f) # 每个文件的目标路径 shutil.copy(dep_path, arr_path) print(&quot;*** Copy end ***&quot;) shutil.rmtree('_book') print(&quot;*** Remove _book ***&quot;) print(&quot;*** Push... ***&quot;) os.system(&quot;git add .&quot;) now = datetime.datetime.now() commitMessage = &quot;Update by %d-%02d-%02d %02d:%02d:%02d&quot; % (now.year,now.month,now.day,now.hour,now.minute,now.second) commitCode = &quot;git commit -m '%s'&quot; % commitMessage os.system(commitCode) os.system(&quot;git push origin gh-pages&quot;) print(&quot;*** Checkout master... ***&quot;) os.system(&quot;git checkout master&quot;) else: print(&quot;*** _book is not exists*** &quot;) ","link":"https://daning.netlify.app/post/gitbook-note/"},{"title":"iOS给项目添加多语种","content":"给项目添加多语种时，如果嫌手动添加麻烦，可以尝试此文章方法 在给项目做国际化的时候，需要添加多语种，有2种方式，一种是在 PROJECT-Info-Localizations 里直接选择添加，这里不多做赘述。 另一种是比较简洁的方法：直接修改工程文件，缺啥加啥就行 /* Begin PBXProject section */ 下有个 knownRegions，这个就是对应国际化多语言选项的 knownRegions = ( English, en, // English Base, &quot;zh-Hans&quot;, // 简体中文 de, // 德语 es, // 西班牙 &quot;zh-Hant&quot;, // 繁体中文 fr, // 法语 it, // 意大利 &quot;pt-PT&quot;, // 葡萄牙 ja, // 日语 nl, // Dutch 荷兰语 ko, // 韩语 ru, // Russian 俄语 sv, // Swedish 瑞典语 da, // Danish 丹麦语 fi, // finnish 芬兰语 pl, // Polish 波兰语 nb, // Norwegian 挪威语 hu, // Hungarian 匈牙利语 ar, // Arabic 阿拉伯语 ); ","link":"https://daning.netlify.app/post/xcode-localizaions/"},{"title":"PhotoShop操作笔记","content":"偶尔会需要使用PS去对图片进行操作，在此记录一下部分操作的方法 1. 提取图片中文字 有2种简单的方式去提取图片中文字，一种是用快速选择工具，另一种是新建图层通过色彩范围提取文字 方式1：快速选择工具 这种方式最简单，直接在工具栏选择快速选择工具即可: 处于选中状态后，右键反向选择，然后编辑-&gt;清除即可 方式2：色彩范围提取 打开图片，然后点击创建新图层（经试验，其实不做这一步也可以） 接着点击选择-&gt;色彩范围 然后画笔提取字体颜色，并调整颜色容差值，之后点击确认 此时文字已经处于选中状态，可以通过右键反向选择，然后编辑-&gt;清除，或者进行第5步 cmd+j复制图层，然后选中图片图层，用橡皮擦即可擦除 2. 去水印logo 图片中遮盖区域不太复杂的logo有个比较简单的擦除方式 效果如下 3. 替换颜色 快速替换图片中颜色：顶部菜单-&gt;图像-&gt;调整-&gt;替换颜色 (选中下方的色块后，即可替换新颜色) 4. 删除图片中的文字 使用套索工具圈选文字-&gt;顶部菜单选编辑-&gt;填充-&gt;选择内容识别-&gt;确认即可 5. 美颜 选中涂层后 -&gt; 滤镜 -&gt; 液化 功能都在里面了 ","link":"https://daning.netlify.app/post/ps-notes/"},{"title":"使用Netlify加速Github Pages访问速度(Jekyll)","content":"使用 Github Pages 配合 Jekyll 搭建个人博客，即免费又便捷，但其有一个很大的问题就是国内的访问速度很慢，为了低成本的解决这个问题，在此介绍一个服务：Netlify 一. Netlify简介 Netlify是一家提供静态网站托管的综合平台，支持自动从Github等仓库拉取代码，并构建网站进行发布，同时也支持自定义域名、自动申请SSL证书等功能； 最重要的同时也是我们所关注的就是自动启动CDN加速，国内访问速度会快上不少。 二. 配置 首先打开 Netlify官网 然后进行一系列配置，很简单，就不详细说明了；不过有几点要注意： 博客根目录要配置Gemfile：因为Netlify在构建网页时需要知道自己该以怎样的方式去构建source 'https://rubygems.org' #配置Netfily的话，因为其服务器在国外，因此用此源 # source 'https://gems.ruby-china.com' #本地执行的时候为了加速，将源改为ruby-china gem &quot;jekyll&quot; group :jekyll_plugins do gem 'jekyll-feed' gem 'jekyll-seo-tag' gem 'jekyll-sitemap' gem 'jekyll-paginate' end Build &amp; deploy配置下，Build command要填jekyll build,Publish directory要填_site 配置完成后，就稍作等待就可以访问了 三. site修改 site name是可以随意修改的，也绑定自己的域名(custom domain)； 绑定自己的域名可以提供自己已经购买好的域名，或者直接在Getting started的第二步(实际操作的时候就知道在哪)，直接填写； 尝试填了一个，经历千万次重名提示后，提示我第一年要$10.99，以后每年要$14.99。Em............🤔 ヾ(￣▽￣)ByeBye ","link":"https://daning.netlify.app/post/how-to-use-netlify/"},{"title":"Cocoapods相关问题","content":"使用Cocoapods时偶尔会遇到一些奇怪的问题，在此记录，方便查询 1.pod install或者pod search时，报错 如： error: Failed to open TCP connection to raw.githubusercontent.com:443 (Connection refused - connect(2) for \"raw.githubusercontent.com\" port 443) 解决方法： 执行pod repo remove trunk移除trunk源，然后pod search就都正常了 2. pod init 报错 如： ····· RuntimeError - [Xcodeproj] Unknown object version. ····· 解决方式： sudo gem update xcodeproj --pr ","link":"https://daning.netlify.app/post/cocoapods-problems/"},{"title":"Xcode利用shell更改build号","content":"编译iOS项目时，也许会遇到自动更改build号这样的需求，用来上架或其他用途。 利用python或者shell脚本都可以做到这点，这里简述shell脚本使用方式 使用方法： Build Phases里增加一个Run Script即可 plist=${INFOPLIST_FILE} buildNumber=$(date +%Y%m%d%H%M) /usr/libexec/PlistBuddy -c &quot;Set :CFBundleVersion $buildNumber&quot; &quot;$INFOPLIST_FILE&quot; ","link":"https://daning.netlify.app/post/use-sh-change-version/"},{"title":"Xcode利用shell编译sdk","content":"Xcode编译工程的时候，可以在Build Phases里增加Run Script脚本，用来打包SDK、运行Python修改工程信息或者其他功能，这里简单介绍一下使用Shell脚本来辅助打包SDK的相关知识； 在打包SDK的时候，有时要打模拟器和真机包2个包，然后进行合包从而生成模拟器和真机都支持的SDK，本文就是主要阐述如何通过Shell脚本，来实现上述步骤。 1.lipo 介绍Shell前，我们需要先了解一下lipo命令。什么是lipo？从字面意思理解，它是脂肪的意思，app为了兼容不同的架构（armv7, arm64, i386, x86_64...），需要将不同平台的编译程序合并起来，生成所谓的胖文件（Fat File），而我们的lipo，就是用来干这个的。 1.查看静态库（通用文件）支持的CPU架构 lipo -info libname.a 输出：Architectures in the fat file: libname.a are: i386 x86_64 armv7 arm64 2.合并静态库 #lipo -create 静态库存放路径1 静态库存放路径2 ... -output 整合后存放的路径 lipo -create libname-armv7.a libname-armv7s.a libname-i386.a -output libname.a 3.静态库拆分或者“瘦身”（提取单个平台） # lipo 静态库源文件路径 -thin CPU架构名称 -output 拆分后文件存放路径 # 架构名为armv7/armv7s/arm64等，与lipo -info 输出的架构名一致 lipo libname.a -thin armv7 -output libname-armv7.a 4.提取、替换和去除指定CPU架构 # 提取出armv7架构并新建一个通用文件，类似于-thin选项。 lipo -extract armv7 libname.a -output libname_armv7.a #去除armv7架构 lipo -remove armv7 libname.a -output libname_exceptArmv7.a #对输入文件libname.a中的armv7架构文件采用librepace.a进行替换，并输出到liboutput.a中 lipo libname.a -replace armv7 libreplace.a -output liboutput.a 2.Shell 命令 暂时不打算仔细学习Shell语法，如果以后有经常使用Shell的场景，会回头再起文章记录，这里就简单记录一下Run Script里会用到的常见语法 1.shell中的各种括号 要注意的是，使用[]和[[]]的时候不要吝啬空格，每一项两边都要有空格，[[ 1 == 2 ]]的结果为“假”，但[[ 1==2 ]]的结果为“真”！后一种显然是错的 1.1 (): 括号中的命令将会新开一个子shell顺序执行，括号中多个命令之间用分号隔开 #具体使用场景暂时未了解 #个人理解了一下，貌似是类似于在终端直接输入，例如下面我本想判断环境变量ACTION的值 if ( &quot;${ACTION}&quot; == &quot;install&quot; ) #但是输出却是 install: ==: No such file or directory 1.2 (()) : 是一种数学计算命令，它除了可以进行最基本的加减乘除运算，还可以进行大于、小于、等于等关系运算，以及与、或、非逻辑运算。这种扩展计算是整数型的计算，不支持浮点型（没试过）。 #依然以这个判断为例，这样写就没问题了 if (( &quot;${ACTION}&quot; == &quot;install&quot; )) #之前为了判断字符串相等，加了双引号，后来试了一下，不加双引号也没问题 if (( ${ACTION} == &quot;install&quot; )) 1.3 []：用来用于字符串比较的，不可用于整数比较 #同样的，加不加双引号都行，字符串比较的话还是用[]吧 if [ &quot;${ACTION}&quot; == &quot;install&quot; ] if [ ${ACTION} == &quot;install&quot; ] 1.4 [[]]：在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换(暂时不理解，留作备注)。 #支持字符串的模式匹配，例如 [[ hello == hell? ]]，结果为真 #[[ ]] 中匹配字符串或通配符，不需要引号 2.if elif else 语法 if语法其实很简单,写 if 和 else if的时候，后面加个then就完事，写完if整个逻辑后用fi收尾即可； shell的if语法和C语言等高级语言非常相似，唯一需要注意的地方就是shell的if语句对空格方面的要求比较严格(其实shell对所有语法的空格使用都比较严格)，如果在需要空格的地方没有打上空格，都会报错。 if (( $a == $b )) then echo &quot;a和b相等&quot; else if (( $a &gt; $b || $a &lt; $b)) then echo &quot;a不等于b&quot; else echo &quot;进不来的&quot; fi 3.shell中条件判断if中的-z到-d的意思 [ -a FILE ] 如果 FILE 存在则为真。 [ -b FILE ] 如果 FILE 存在且是一个块特殊文件则为真。 [ -c FILE ] 如果 FILE 存在且是一个字特殊文件则为真。 [ -d FILE ] 如果 FILE 存在且是一个目录则为真。 [ -e FILE ] 如果 FILE 存在则为真。 [ -f FILE ] 如果 FILE 存在且是一个普通文件则为真。 [ -g FILE ] 如果 FILE 存在且已经设置了SGID则为真。 [ -h FILE ] 如果 FILE 存在且是一个符号连接则为真。 [ -k FILE ] 如果 FILE 存在且已经设置了粘制位则为真。 [ -p FILE ] 如果 FILE 存在且是一个名字管道(F如果O)则为真。 [ -r FILE ] 如果 FILE 存在且是可读的则为真。 [ -s FILE ] 如果 FILE 存在且大小不为0则为真。 [ -t FD ] 如果文件描述符 FD 打开且指向一个终端则为真。 [ -u FILE ] 如果 FILE 存在且设置了SUID (set user ID)则为真。 [ -w FILE ] 如果 FILE 如果 FILE 存在且是可写的则为真。 [ -x FILE ] 如果 FILE 存在且是可执行的则为真。 [ -O FILE ] 如果 FILE 存在且属有效用户ID则为真。 [ -G FILE ] 如果 FILE 存在且属有效用户组则为真。 [ -L FILE ] 如果 FILE 存在且是一个符号连接则为真。 [ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last read则为真。 [ -S FILE ] 如果 FILE 存在且是一个套接字则为真。 [ FILE1 -nt FILE2 ] 如果 FILE1 has been changed more recently than FILE2,or 如果 FILE1 exists and FILE2 does not则为真。 [ FILE1 -ot FILE2 ] 如果 FILE1 比 FILE2 要老, 或者 FILE2 存在且 FILE1 不存在则为真。 [ FILE1 -ef FILE2 ] 如果 FILE1 和 FILE2 指向相同的设备和节点号则为真。 [ -o OPTIONNAME ] 如果 shell选项 “OPTIONNAME” 开启则为真。 [ -z STRING ] “STRING” 的长度为零则为真。 [ -n STRING ] or [ STRING ] “STRING” 的长度为非零 non-zero则为真。 3.Xcode 环境变量 ACTION: 编译模式，archive-&gt;&quot;install&quot;、build-&gt;&quot;build&quot; SRCROOT: 根目录，~/Desktop/Linkplay/ios_muzoplayer/LPVBSKit BUILD_ROOT: 构建目录，~/Library/Developer/Xcode/DerivedData/.../Build/Products CONFIGURATION: 编译模式Debug、Release PROJECT_NAME: 工程名，LPVBSKit TARGETNAME: target名，LPBLESetupKit BUILD_DIR: 编译后路径，archive后里面分别有Release-iphoneos、iphonesimulator、universal三个文件夹 /Users/yining/.../LPVBSKit-xxx/.../LPBLESetupKit/BuildProductsPath TARGET_BUILD_DIR:也是编译路径，BUILD_DIR下的文件的原始地址 /Users/yining/.../LPVBSKit-xxx/.../LPBLESetupKit/IntermediateBuildFilesPath/UninstalledProducts/iphoneos 4.编译SDK的Shell 4.1 shell代码 格式化代码加了空格仅仅是为了方便阅读，真实环境不用加，也不确定加了是否对使用造成影响 #Release-universal文件目录 UNIVERSAL_OUTPUTFOLDER=${BUILD_DIR}/${CONFIGURATION}-universal #项目下Products文件夹的路径 INSTALL_DIR=${SRCROOT}/Products #创建Release-universal文件目录，实验了一下，即便不手动创建，archive也会自动创建 mkdir -p &quot;${UNIVERSAL_OUTPUTFOLDER}&quot; #删除Products文件夹 if [ -d &quot;${INSTALL_DIR}&quot; ] then rm -rf &quot;${INSTALL_DIR}&quot; fi #重新创建文件夹(-p 的作用是即使上级目录不存在，也会按目录层级自动创建目录，起一个保护作用，防止创建失败) mkdir -p &quot;${INSTALL_DIR}&quot; #判断是不是根调用，不是根调用，不要递归（估计就是防止多余调用） if [ &quot;false&quot; == ${ALREADYINVOKED:-false} ] then #1.首先确认是在archive if [ &quot;${ACTION}&quot; = &quot;install&quot; ] then #2. 设置环境变量 ALREADYINVOKED 为 true（防止多次调用,例如同个项目下，可能有多个targetSDK，如果相互引用，就能确保仅打包一个SDK了，**猜的！**） export ALREADYINVOKED=&quot;true&quot; #3. 开始编译模拟器环境SDK xcodebuild -target &quot;${TARGETNAME}&quot; -configuration ${CONFIGURATION} -sdk iphonesimulator ONLY_ACTIVE_ARCH=NO BUILD_DIR=&quot;${BUILD_DIR}&quot; BUILD_ROOT=&quot;${BUILD_ROOT}&quot; clean build #4. 将生成的framework拷贝至universal文件夹下面(-R/r 是递归操作，会将目录下的文件/文件件一起拷贝) cp -R &quot;${BUILD_DIR}/${CONFIGURATION}-iphoneos/${TARGETNAME}.framework&quot; &quot;${UNIVERSAL_OUTPUTFOLDER}/&quot; #5. 将Release-iphonesimulator/iphoneos文件夹下的framework文件夹下的执行文件合包，替换universal文件夹下framework的执行文件 # 注：虽然是替换了universal下的文件，但其实universal里的文件，指向的是TARGET_BUILD_DIR下的文件，所以修改universal下framework的文件，就是在修改源文件 lipo -create -output &quot;${UNIVERSAL_OUTPUTFOLDER}/${TARGETNAME}.framework/${TARGETNAME}&quot; &quot;${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${TARGETNAME}.framework/${TARGETNAME}&quot; &quot;${BUILD_DIR}/${CONFIGURATION}-iphoneos/${TARGETNAME}.framework/${TARGETNAME}&quot; #6. 打开Products文件夹，并把BUILD_DIR下的framework拷贝过来（可以右键查看原文件） #注：这个framework其实指向的也是TARGET_BUILD_DIR下的framework，但是直接拷贝TARGET_BUILD_DIR的话，就没法右键查看原文件，其实没啥区别 open &quot;${INSTALL_DIR}&quot; cp -R &quot;${BUILD_DIR}/${CONFIGURATION}-iphoneos/${TARGETNAME}.framework&quot; &quot;${INSTALL_DIR}/${TARGETNAME}.framework&quot; fi fi 4.2 步骤说明 Release-iPhoneos 和 Release-universal下的framework指向的其实都是TARGET_BUILD_DIR的原文件 archive后，先把Release-iPhoneos下的framework copy至Release-universal下 将Release-iphoneos和Release-iphonesimulator下的执行文件合包，并覆盖到Release-universal下 将Release-iphoneos拷贝至Products目录下，方便拿去使用 4.3 路径图解 BUILD_DIR下的Release-iPhoneos/Release-universal TARGET_BUILD_DIR下的原文件 ","link":"https://daning.netlify.app/post/xcode-run-script-shell/"},{"title":"安装Jekyll","content":"Jekyll也是一种搭建个人博客的方式，本文讲简述如何安装Jekyll并调试。 一、安装 Jekyll官网 安装前需要确认环境：Xcode、Ruby。（MacOS自带Ruby、Xcode不用解释） 环境没有问题的话，就可以直接安装jekyll了. sudo gem install bundler jekyll (bundler)说明：Ruby Project依赖于一系列的ruby gems.而bundler是一个很好的管理ruby项目gems的工具。当然也是一个ruby gem. 二、调试 经过几分钟的安装后，就可以调试了 1.查看jekyll版本可以用 jekyll -v 2.到项目根目录下，运行jekyll server即可启动本地server http://127.0.0.1:4000/ jekyll server 3.启动成功后，直接在浏览器输入http://127.0.0.1:4000/即可同步调试 三、报错汇总 3.1 启动server时，可能会遇到不同的错误，我在使用时，遇到的问题基本是缺少不同的jekyll库，遇到这种问题很简单，安装对应的库即可，例如： 很明显缺少jekyll-sitemap，安装即可： sudo gem install jekyll-sitemap 3.2 尝试配置Linkplay SDK Github Pages时，按照其对应的模板执行了 bundle install 由于调试了其他的jekyll theme，在调试时按照步骤执行了bundleinstall bundle install后，会根据目录下的Gemfile文件自动安装很多库，具体没研究，不过再次启动本地调试的话，之前的jekyll server已经不行了； 此时想要本地调试需要2步： Gemfile文件，模板如下(不指定版本也行) source 'https://rubygems.org' gem &quot;jekyll&quot;, '3.8.4' group :jekyll_plugins do gem 'jekyll-feed', '0.11.0' gem 'jekyll-seo-tag', '2.5.0' gem 'jekyll-sitemap', '1.2.0' gem 'jekyll-paginate' end 创建完成后就可以通过执行 bundle exec jekyll serve 来拉起本地server http://127.0.0.1:4000 ;同时会生成Gemfile.lock文件，可忽略 当然也可以解决以上问题，将其恢复到 jekyll serve 的方式； 先删除Gemfile.Lock文件，然后重新编辑Gemfile，将jekyll 升级到最新的4.0.0： source 'https://rubygems.org' #配置Netfily的话，因为其服务器在国外，因此用此源 #source 'https://gems.ruby-china.com' #本地执行的时候为了加速，将源改为ruby-china gem &quot;jekyll&quot;, '~&gt; 4.0.0' group :jekyll_plugins do gem 'jekyll-feed' gem 'jekyll-seo-tag' gem 'jekyll-sitemap' gem 'jekyll-paginate' end 重新bundle install，成功后即可重新使用 jekyll serve 来进行本地调试了 最后为了Netfily，记得吧Gemflie和Gemfile.lock文件中的Gem sourse改回 https://rubygems.org ","link":"https://daning.netlify.app/post/install-jekyll/"},{"title":"喜欢的文案","content":"记录一些平时看到的，喜欢的或者有意义的句子。 女学生白天上课，晚上当妓女，这是负能量。妓女晚上接客，白天坚持上学，这就是正能量。屡战屡败，是愚蠢。屡败屡战，是勇气。 花有重开日，人无再少年 回首向来萧瑟处，归去，也无风雨也无晴; 竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生。(喜欢这个顺序，原文不是这样的) 每个男人都想当至尊宝有梦想的日子，简单快乐，却不得不戴上紧箍咒，变成齐天大圣，但你会失去了很多；生活就是紧箍咒，社会就是牛魔王，父母就是唐僧，紫霞就是梦想，可是...你却活的像条狗 ---《网易云》 但愿老死花酒间，不愿鞠躬车马前。车尘马足显者事，酒盏花枝隐士缘。若将显者比隐士，一在平地一在天。若将花酒比车马，彼何碌碌我何闲。 淡看世事去如烟，铭记恩情存如血。 醉里乾坤大，梦中日月长。 什么事人性？打个比方：一群人被困在一个屋子里，屋外有一只凶猛的野兽要扑进来吃人，这时所有人都必须齐心协力顶着房门阻止野兽进来，这个时候，大家同生死共患难的过命交情就这样建立下来了。这是人性！但是，如果猛兽已经冲垮了房门扑进屋子，它的尖牙利爪无可抵挡，此时人们要活下去的唯一希望就是跑出屋子，但房门只有一个，为了争夺这一线生机，大家自相践踏，你拉我扯，甚至自相残杀，这个过程，不共戴天的怨仇就如此酿成了。这也是人性！ “交情，那是什么东西，现在的情况就是，我需要人为我分担压力，孙瑞星可能会破坏我们的计划，破坏了我的计划，就是拦了我的路，拦了我的路，就是想要我的命，要我的命，就是我的仇人，对待仇人，我还讲什么交情，只是，我对孙瑞星这个人，还是有点欣赏的，只希望，他不会走上与我为敌的这条路。所以，看紧点儿，孙瑞星有什么异动，杀了他，杀不了，叫我。” 哪有什么岁月静好，只不过有人在替你负重前行。 常思人世漂流无常，譬如朝露，水中映月，刹那繁华瞬间即逝。风流人物，今非昔比，人生五十年，莫非熙熙攘攘，浮生幻梦，名垂青史，功败湮灭，只是宿命因果... 大部分人在二三十岁就死了，因为过了这个年龄，他们只是自己的影子。此后的余生则是在模仿自己中度过。日复一日，更机械，更装腔作势的重复他们有生之年的所作所为，所思所想，所爱所恨。--- 罗曼·罗兰 一直觉得，探戈是闷骚到极致的舞蹈。每一个回眸，顾盼风流；每一次贴近，欲迎还拒。不苟言笑的冰冷，却早已是心猿意马；面上的一本正经，掩不住心底的暗潮涌动。像极了棋逢对手的食色男女，一面调情又一面暗自较量，究竟是谁先俘获了对方的心。 莫愁前路无知己，天下谁人不识君。 穷则独善其身，达则兼济天下。 我们这群人，苦没有真正的苦过，爱没有用力的爱过。每天受着信息大潮的冲击，三观未定又备受曲折。贫穷不再是正义，又妄图不让金钱成为唯一的追求。过早看到了更大的世界，勤奋却又不过三天。热血透不过屏幕，回忆止于游戏和工作。像一群没有根的孩子，在别人的经历和精神力吵闹。---《网易云》 过了这么多年，我终于发现了那些让我喜欢的人的特质，他们总是生机勃勃的，有自己喜欢的事情，不过多干涉别人的生活，懂得人际交往的边界，不四处炫耀自己所拥有的一切，言辞温和，与人为善，适度的野心。容得下生命的不完美，也经得起世事的颠簸，将人生的一切都根植于生活。 “一旦融入一个群体，你就会传染上他们的动作、习惯以及思维方式，做出一些荒唐可笑但毫不自知的事情，小丑跳出这个圈了，但是蝙蝠侠没有...” 这世上只有一种成功，就是能够用自己喜欢的方式度过自己的一生 ---《头文字D》 秋风未动蝉先觉，暗算无常死不知。 半神半圣亦半仙，全儒全道是全贤，脑中真书藏万卷，掌握文武半边天。 人嘛，活这一辈子，做自己认为正确的事情就可以了。生命的本身是没有意义的，真正有意义的是，在生命中，你做出过哪些选择，又有过哪些行为。 --- 《九星毒奶》 鲁迅说过：假如上半年混的不好，千万不要气馁。因为：七一建党，八一建军，十一建国，伟大的事业都是在下半年完成的。上半年不是三八就是清明，不是五四就是六一，都还不太成熟。（鲁迅表示自己没说过） 每个人都有自己的长处和短处，正视自己的短处并不是什么丢人的事情。 事未必非要极致，功绝对不可尽得。 梧高凤必至，花香蝶自来。 烦躁时看一个人的修养，独处时最显一个人的人品。 --- 卡耐基 第一次见面就让你觉得不舒服的人，尽量保持距离。 --- 卡耐基 懦夫在未死之前，就已经死过很多次了。勇士，一生只死一次。 --- 《九星毒奶》·武浩阳 世间事无非是戏，人间人何须认真。让三分天高地厚，争一分山穷水尽。 自己喜欢的东西就不要问别人好不好看... 把你认为有价值的东西，分享给那些不懂的人，这是一种自取其辱式的孤独。 小时候爱吃西红柿，以为会一辈子爱吃，等到长大不爱吃了就是不爱吃了，没有理由，我们没有错，西红柿也没有错，错的只是那些自以为是的一辈子。 其实我知道，山的那边依旧是山，和这边并没有什么很大的不同，只是不甘愿在本就漫长而寂寥、喧嚣又飞逝的一生中，站成了一棵树。到不了远方，怎么看得见自己。 没钱的时候就当哑巴别打扰任何人，天上下雨地下滑，自己跌倒自己爬。想要别人帮，酒换酒，茶换茶。 所谓孤独就是 '有的人无话可说’，‘有的话无人可说’。 我越是安静，越是平和，越是淡定，越是忍耐，越是无所谓，我眼里深藏着的汹涌就越沸腾。 其实人跟树是一样的，越是向往高处的阳光，它的根就越要伸向黑暗的地底。 生于理想，死于现实。有人的25岁就死了，直到75岁才埋葬。所有男孩子小时候的梦想，绝对不是在城里买一套房。 天底下有一句话特别对，冤枉你的人比你还知道你有多冤枉 --- 郭德纲 做奴隶虽然不幸，但并不可怕，因为知道挣扎，毕竟还有挣脱的希望；若是从奴隶生活中寻出美来，赞叹、陶醉，就是万劫不复的奴才了！ --- 鲁迅 你可以追求金钱名利，你也可以追求诗酒花茶，你可以追求江上之清风，也可以追求山间之明月。但是不用过分在意追求的结果，结果终将逝去。 当牛做马的温饱，溜须拍马的肚圆，声色犬马的富贵，指鹿为马的遮天。 学士服是租的，毕业照是学校安排的，论文是抄的，答辩是水的，实习报告是假的，三方合同是骗就业率的···一切都是假的，只有时间是真的，它每天都在告诉我们，青春，终究是要散场。 一蓑一笠一扁舟，一丈丝纶一寸钩；一曲高歌一樽酒，一人独钓一江秋。 人生就是哭给自己听，笑给别人看。 生活就是屋里狼吃肉，外面狗争骨，要是羊看不惯反抗，不用屋里狼说话，那些狗就会冲出来。 人一到群体中，智商就严重降低，为了获得认同，个体愿意抛弃是非，用智商去换取那份让人备感安全的归属感。 --- 《乌合之众》 人生就应该如同蜡烛一样，从头燃到尾，始终光明。--- 《第一序列》 这世间总是让更懂事的人，承受更多；脾气好的都在受气，善解人意的都在体谅，会照顾人的都没人照顾，会哭会闹的人有糖吃，那些懂事的人，反而，没人心疼。 有情饮水饱，无情金屋寒。 内心再强大一点，就不会听风是雨。知道的事再多一点，就不会人云亦云。 春风得意时，布好局，方能四面楚歌时，有退路。做人，要心中有佛，手里有刀。走心时，不留余力；拔刀时，不留余地！ 当你有金刚手段，具备碾压实力时，再谈：'得饶人处且饶人' 将军有剑，不斩苍蝇；水深不语，人稳不言；谋大事者，藏于心，行于事； 所有的客观都是主观，所有的意见都是偏见，人只相信他所愿意相信的，不需要花费力气去说服别人，能做到准确的表达自己，就很好了。 良言一句三冬暖，恶语伤人六月寒。 人生不过百，常怀千岁忧。 我被生活栓在这方寸之地，尽管可以眺望远方，也向往自由，但也仅限于此！ 天下万般兵刃，唯有过往伤人最深。 --- 亚索 关山难越，谁悲失路之人？萍水相逢，尽是他乡之客。 小时候我们词不达意，长大后我们言不由衷。 时来天地皆同力，运去英雄不自由。 兴家犹如针挑土，败家好似浪淘沙。 欲买桂花同载酒，终不似，少年游。 天雨虽大不润无根之草，佛法虽宽不渡无缘之人。 大鹏一日同风起，扶摇直上九万里。 待到秋来九月八，我花开后百花杀。 黑白本一色，只因事无常。---《画江湖之不良人》 乾坤未定，你我皆黑马； 莫以一时得失定天下。--- ​国学文化《菜根谭》 凡是过往，皆为序章。(What's past is prologue) --- 莎士比亚戏剧《暴风雨》 大风可以吹起一张白纸，却无法吹走一只蝴蝶，因为生命的力量在于不顺从。---​ 冯骥才 心似已灰之木，身如不息之舟。 旧社会把人变成鬼，新社会把鬼变成人。 上善若水，水善利万物而不争。 山野万万里，余生路漫漫，日暮酒杯淡饭，一半一半。 平生不修善果，只爱杀人放火。 忽地顿开金绳，这里扯断玉锁。 咦！ 钱塘江上潮信来，今日方知我是我。 --- 鲁智深 心平能愈三千疾，心静可通万事理。 大梦谁先觉？平生我自知。--- 罗贯中《大梦谁先觉》 所谓见过世面，不是去过某些高档场景，穿过什么大牌衣服，或者去过某个地方旅游。而是当人性在你面前徐徐展开，当各种匪夷所思行为在你面前暴露，你却如此宁静与坦然。因为你早已体会人生的百态，见天地之道，阅众生之相，世面就是世界的每一面，见过最好的，且不以物喜，知晓最坏的，却不以己悲，乱花渐欲，不坠青云志，腹有诗书不夸夸其谈，见过世界的光明与阴淡，体会过人性的复杂多变，和喜怒无常，做到不急不躁，风轻云淡和光同尘。 凡事向外求，十年如一日，向内求，日日如新生；观内心而本自具足，阅万物而虚怀若谷；内求诸己，不假外物，吾信自足，不假外求；(寻求外部的东西，如物质、地位、他人的认可，可能会让人陷入一种停滞不前的状态。通过内省和自我探索，人们可以每天都有新的理解和成长。通过观察和了解自己的内心，人们会发现自己本来就拥有足够的资源和能力。面对外界的万物，保持一颗开放和谦逊的心，像山谷一样能够包容一切。寻求内在的智慧和力量，而不是依赖外在的物质或他人的帮助。相信自己已经足够，不需要外界的补充或认可。) 纵情于行动，坦言于结局。 财富是对认知的补偿，不是对勤劳的奖赏。 门前榜出雕虫技，座上邀来射虎人**--- 红豆茶《古代世界唯一玩家》** 过往皆是因，当下皆是果。 棋局成败，不在一招，而在招招。人生成败，不在一朝，而在朝朝昨日之深渊，今日之浅谈。 路虽远，行则将至；事虽难，做则可成。 风吹哪页读哪页，且行且看且随风。 恶难皆常象，非是登云梯。 面对罪恶没有勇气去做殉道者，却试图靠着别人的牺牲来满足自己的正义感，这是最恶心的善良。--- 指间青烟《人间无敌：从监狱开始崛起》 ","link":"https://daning.netlify.app/post/good-sentences/"},{"title":"MarkDown简单用法","content":"Markdown 是一种轻量级标记语言，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。 1.常用语法 标题 1~4个#加上空格，代表4个字号的标题 高亮强调： 就是两个反引号把内容括起来 `` 引用符号： &gt; 用来突出内容 字体加粗 ： **字体加粗** 字体斜体： *字体斜体*： 菜单： 菜单用-、+、*加空格都可以 链接： 格式：[标签名字]（链接地址） 百度[百度](https://www.baidu.com) 网址： 常规样式：https://www.jianshu.com/u/97ee21e3f77f 超链接样式： https://www.jianshu.com/u/97ee21e3f77f&lt;https://www.jianshu.com/u/97ee21e3f77f&gt; 插入图片 例： 代码![描述](图片地址) #例如： ![blog头像图片](../images/blog.jpg) 分割线： // 就是3个星号 *** 或者用html标签&lt;hr&gt; 视频： &lt;video id=&quot;video&quot; controls=&quot;&quot; preload=&quot;none&quot; poster=&quot;https://i.loli.net/2020/01/09/n9bcw14OXN82lMD.png&quot;&gt; &lt;source id=&quot;mp4&quot; src=&quot;https://video.pearvideo.com/mp4/third/20200109/cont-1640431-10042874-102056-hd.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;/video&gt; 音频： &lt;audio id=&quot;audio&quot; controls=&quot;&quot; preload=&quot;none&quot;&gt; &lt;source id=&quot;mp3&quot; src=&quot;http://qiniu.cloud.fandong.me/Music_iP%E8%B5%B5%E9%9C%B2%20-%20%E7%A6%BB%E6%AD%8C%20%28Live%29.mp3&quot;&gt; &lt;/audio&gt; 2.代码块 以Python为例 # 示例 ```python import os print('python 代码块？') # OC和html同理：ObjectiveC、html 3.表格: | 左对齐 | 居中 | 右对齐 | | ------ | :---: | -----: | | 香蕉 | $1 | 5 | | 苹果 | $1 | 6 | | 草莓 | $1 | 7 | 左对齐 居中 右对齐 香蕉 $1 5 苹果 $1 6 草莓 $1 7 4.锚点 可以利用html的a标签，进行锚点跳转，例：A、B互跳 锚点A 锚点B &lt;a id=&quot;text&quot; href=&quot;#sssss&quot;&gt;锚点A&lt;/a&gt; &lt;a id=&quot;sssss&quot; href=&quot;#text&quot;&gt;锚点B&lt;/a&gt; 4.快捷键 字体加粗 ：conmmond + b 字体斜体：conmmond + i 标题VSCode快捷键 变大： shift + ctrl + [ 缩小： shift + ctrl + ] ","link":"https://daning.netlify.app/post/markdown-note/"}]}